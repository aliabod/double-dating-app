/////////////////////////////////////////////// WARNING ///////////////////////////////////////////////
// Be aware that if you decide to add comments to this or any other non-private file, they could     //
// end up in our *public* auto-generated swagger documentation. In order to ensure that your         //
// comments are not included in our swagger docs, put one line of whitespace between your comment    //
// and any proto definitions.                                                                        //
///////////////////////////////////////////////////////////////////////////////////////////////////////


syntax = "proto3";

import "proto/clarifai/api/resources.proto";
import "proto/clarifai/api/status/status.proto";
import "proto/clarifai/api/utils/extensions.proto";
import "proto/clarifai/auth/scope/scope.proto";
import "proto/clarifai/auth/util/extension.proto";
import "proto/clarifai/commands/commands.proto";
import "proto/clarifai/api/status/status_code.proto";

import "google/api/annotations.proto";
import "google/protobuf/duration.proto";
import "google/protobuf/struct.proto";
import "google/protobuf/timestamp.proto";


package clarifai.api;

option go_package = "api";
option java_multiple_files = true;
option java_package = "com.clarifai.grpc.api";
option objc_class_prefix = "CAIP";

/*
  Note: this is based on the google api format defined here. Please
  read this before contributing to this file and other *.proto files
  for the API.
  https://cloud.google.com/service-management/reference/rpc/google.api#google.api.HttpRule
 */

message TestMessage {
  clarifai.api.status.Status status = 1;
  string value = 2;
  bytes byts = 3;
  uint32 int_32 = 4;
  uint64 int_64 = 5;
  float f_32 = 6;
  double f_64 = 7;

  // To handle arbitrary json you can use a struct field:
  // https://github.com/google/protobuf/blob/master/src/google/protobuf/struct.proto
  google.protobuf.Struct s = 8;
}


service V2 {

  // Common echo example.
  rpc Echo (TestMessage) returns (TestMessage) {
    option (google.api.http) = {
      post: "/v2/example/echo"
      body: "*"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
  }

  ////////////////////////////////////////
  // Concept Relationships
  ////////////////////////////////////////


  // List concept relations between concepts in the platform.
  // MUST be above ListConcepts so that if concept_id is empty this will still match
  // /concepts/relations to list all the concept relations in the app.
  rpc ListConceptRelations (ListConceptRelationsRequest) returns (MultiConceptRelationResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/concepts/{concept_id}/relations"
      additional_bindings1 {
        get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/concepts/relations"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
  }


  // Post concept relations to create relations between concepts in the platform.
  rpc PostConceptRelations (PostConceptRelationsRequest) returns (MultiConceptRelationResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/concepts/{concept_id}/relations"
      body: "*"
    };
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
  }

  // Post concept relations to create relations between concepts in the platform.
  rpc DeleteConceptRelations (DeleteConceptRelationsRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/concepts/{concept_id}/relations"
      body: "*"
    };
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Delete;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
  }


  ////////////////////////////////////////
  // Concepts
  ////////////////////////////////////////

  // List all the concepts with their positive and negative counts
  rpc GetConceptCounts (GetConceptCountsRequest) returns (MultiConceptCountResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/concepts/status"
      additional_bindings2 {
        get: "/v2/concepts/status"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
  }

  // Get a specific concept from an app.
  rpc GetConcept (GetConceptRequest) returns (SingleConceptResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/concepts/{concept_id}"
      additional_bindings3 {
        get: "/v2/concepts/{concept_id}"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
  }

  // List all the concepts.
  rpc ListConcepts (ListConceptsRequest) returns (MultiConceptResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/concepts"
      additional_bindings4 {
        get: "/v2/concepts"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
  }

  // Search over the concepts to find one or more you're looking for.
  // This leverage the "body" parameter because we also have page and
  // per_page as url query param variables in this request.
  rpc PostConceptsSearches (PostConceptsSearchesRequest) returns (MultiConceptResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/concepts/searches"
      body: "*"
      additional_bindings5 {
        post: "/v2/concepts/searches"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get; // as it needs to know the concepts in your workflow's models.
  }

  // Add a concept to an app.
  rpc PostConcepts (PostConceptsRequest) returns (MultiConceptResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/concepts"
      body: "*"
      additional_bindings6 {
        post: "/v2/concepts"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
  }

  // Patch one or more concepts.
  rpc PatchConcepts (PatchConceptsRequest) returns (MultiConceptResponse) {
    option (google.api.http) = {
      patch: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/concepts"
      body: "*"
      additional_bindings7 {
        patch: "/v2/concepts"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
  }
  ////////////////////////////////////////

  ////////////////////////////////////////
  // Vocabs
  ////////////////////////////////////////

  // Get a specific vocab from an app.
  rpc GetVocab (GetVocabRequest) returns (SingleVocabResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/vocabs/{vocab_id}"
      additional_bindings8 {
        get: "/v2/vocabs/{vocab_id}"
      }
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
  }

  // List all the vocabs.
  rpc ListVocabs (ListVocabsRequest) returns (MultiVocabResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/vocabs"
      additional_bindings9 {
        get: "/v2/vocabs"
      }
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
  }

  // Add a vocab to an app.
  rpc PostVocabs (PostVocabsRequest) returns (MultiVocabResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/vocabs"
      body: "*"
      additional_bindings10 {
        post: "/v2/vocabs"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
  }

  // Patch one or more vocabs.
  rpc PatchVocabs (PatchVocabsRequest) returns (MultiVocabResponse) {
    option (google.api.http) = {
      patch: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/vocabs"
      body: "*"
      additional_bindings11 {
        patch: "/v2/vocabs"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
  }

  // Delete a single vocab.
  rpc DeleteVocab (DeleteVocabRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/vocabs/{vocab_id}"
      additional_bindings12 {
        delete: "/v2/vocabs/{vocab_id}"
      }
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Delete;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
  }

  // Delete multiple vocabs in one request.
  rpc DeleteVocabs (DeleteVocabsRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/vocabs"
      body: "*"
      additional_bindings13 {
        delete: "/v2/vocabs"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Delete;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
  }

  // List all the vocabs.
  rpc ListVocabConcepts (ListVocabConceptsRequest) returns (MultiConceptResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/vocabs/{vocab_id}/concepts"
      additional_bindings14 {
        get: "/v2/vocabs/{vocab_id}/concepts"
      }
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
  }

  // Add a vocab to an app.
  rpc PostVocabConcepts (PostVocabConceptsRequest) returns (MultiConceptResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/vocabs/{vocab_id}/concepts"
      body: "*"
      additional_bindings15 {
        post: "/v2/vocabs/{vocab_id}/concepts"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
  }

  // Delete a single concept from a vocab.
  rpc DeleteVocabConcept (DeleteVocabConceptRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/vocabs/{vocab_id}/concepts/{concept_id}"
      additional_bindings16 {
        delete: "/v2/vocabs/{vocab_id}/concepts/{concept_id}"
      }
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Delete;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
  }

  // Delete multiple concepts from a vocab in one request.
  rpc DeleteVocabConcepts (DeleteVocabConceptsRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/vocabs/{vocab_id}/concepts"
      body: "*"
      additional_bindings17 {
        delete: "/v2/vocabs/{vocab_id}/concepts"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Delete;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
  }

  ////////////////////////////////////////

  ////////////////////////////////////////
  // Concept Languages
  ////////////////////////////////////////

  // Get a specific concept from an app.
  rpc GetConceptLanguage (GetConceptLanguageRequest) returns (SingleConceptLanguageResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/concepts/{concept_id}/languages/{language}"
      additional_bindings18 {
        get: "/v2/concepts/{concept_id}/languages/{language}"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
  }

  // List the concept in all the translated languages.
  rpc ListConceptLanguages (ListConceptLanguagesRequest) returns (MultiConceptLanguageResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/concepts/{concept_id}/languages"
      additional_bindings19 {
        get: "/v2/concepts/{concept_id}/languages"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
  }

  // Add a new tranlsation for this concept.
  rpc PostConceptLanguages (PostConceptLanguagesRequest) returns (MultiConceptLanguageResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/concepts/{concept_id}/languages"
      body: "*"
      additional_bindings20 {
        post: "/v2/concepts/{concept_id}/languages"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
  }

  // Patch the name for a given language names by passing in a list of concepts with the new names
  // for the languages.
  rpc PatchConceptLanguages (PatchConceptLanguagesRequest) returns (MultiConceptLanguageResponse) {
    option (google.api.http) = {
      patch: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/concepts/{concept_id}/languages"
      body: "*"
      additional_bindings21 {
        patch: "/v2/concepts/{concept_id}/languages"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
  }

  // TODO(zeiler): we don't have a way to delete the languages currently. This should be rare
  // anyways as users should just patch translations to the right naming.
  // // Delete a single concept translation.
  // rpc DeleteConceptLanguage(DeleteConceptLanguageRequest) returns (clarifai.api.status.BaseResponse) {
  //   option (google.api.http) = {
  //     delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/concepts/{concept_id}/languages/{language}"
  //     additional_bindings22 {
  //       delete: "/v2/concepts/{concept_id}/languages/{language}"
  //     }
  //   };
  // }

  // // Delete multiple concept translations in one request.
  // rpc DeleteConceptLanguages(DeleteConceptLanguagesRequest) returns (clarifai.api.status.BaseResponse) {
  //   option (google.api.http) = {
  //     delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/concepts/{concept_id}/languages"
  //     body: "*"
  //     additional_bindings23 {
  //       delete: "/v2/concepts/{concept_id}/languages"
  //       body: "*"
  //     }
  //   };
  // }

  ////////////////////////////////////////
  // Concept References to third-party IDs.
  ////////////////////////////////////////

  // List the concept in all the outside sources where we found these concepts.
  rpc ListConceptReferences (ListConceptReferencesRequest) returns (MultiConceptReferenceResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/concepts/{concept_id}/references"
      additional_bindings24 {
        get: "/v2/concepts/{concept_id}/references"
      }
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
  }



  ////////////////////////////////////////
  // Knowledge Graph
  ////////////////////////////////////////

  // List all domain graphs.
  rpc ListKnowledgeGraphs (ListKnowledgeGraphsRequest) returns (MultiKnowledgeGraphResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/concepts/knowledge_graphs"
      additional_bindings25 {
        get: "/v2/concepts/knowledge_graphs"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
  }

  // Post domain graphs.
  rpc PostKnowledgeGraphs (PostKnowledgeGraphsRequest) returns (MultiKnowledgeGraphResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/concepts/knowledge_graphs"
      body: "*"
      additional_bindings26 {
        post: "/v2/concepts/knowledge_graphs"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
  }

  // Start concept mapping jobs.
  rpc PostConceptMappingJobs (PostConceptMappingJobsRequest) returns (MultiConceptMappingJobResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/concepts/mappings/jobs"
      body: "*"
      additional_bindings27 {
        post: "/v2/concepts/mappings/jobs"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
  }

  // List all concept mappings for a given concept id.
  rpc ListConceptMappings (ListConceptMappingsRequest) returns (MultiConceptMappingResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/concepts/mappings"
      additional_bindings28 {
        get: "/v2/concepts/mappings"
      }
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
  }

  // Post concept mappings.
  rpc PostConceptMappings (PostConceptMappingsRequest) returns (MultiConceptMappingResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/concepts/mappings"
      body: "*"
      additional_bindings29 {
        post: "/v2/concepts/mappings"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
  }

  ////////////////////////////////////////
  // annotations
  ////////////////////////////////////////

  // Get a specific annotation from an app.
  rpc GetAnnotation (GetAnnotationRequest) returns (SingleAnnotationResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/inputs/{input_id}/annotations/{annotation_id}"
      additional_bindings30 {
        get: "/v2/inputs/{input_id}/annotations/{annotation_id}"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get; // to get the model for the worker.
  }

  // List all the annotation.
  rpc ListAnnotations (ListAnnotationsRequest) returns (MultiAnnotationResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/annotations"
      additional_bindings31 {
        get: "/v2/annotations"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get; // to get the model for the worker.
  }

  // Post annotations.
  rpc PostAnnotations (PostAnnotationsRequest) returns (MultiAnnotationResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/annotations"
      body: "*"
      additional_bindings32 {
        post: "/v2/annotations"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get; // to know the models in your default workflow.
  }

  // Patch one or more annotations.
  rpc PatchAnnotations (PatchAnnotationsRequest) returns (MultiAnnotationResponse) {
    option (google.api.http) = {
      patch: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/annotations"
      body: "*"
      additional_bindings33 {
        patch: "/v2/annotations"
          body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get; // to know the models in your default workflow.
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get; // to get the model for the worker.
  }

  // Patch annotations status by worker id and task id.
  rpc PatchAnnotationsStatus (PatchAnnotationsStatusRequest) returns (PatchAnnotationsStatusResponse) {
    option (google.api.http) = {
      patch: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/task/{task_id}/annotations/status"
      body: "*"
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
  }

  // Delete a single annotation.
  rpc DeleteAnnotation (DeleteAnnotationRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/inputs/{input_id}/annotations/{annotation_id}"
      additional_bindings34 {
        delete: "/v2/inputs/{input_id}/annotations/{annotation_id}"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Delete;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get; // for cleaning up some optimizations we have in DB layer for annotations.
  }

  // Delete multiple annotations in one request.
  rpc DeleteAnnotations (DeleteAnnotationsRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/inputs/annotations"
      body: "*"
      additional_bindings35 {
        delete: "/v2/inputs/annotations"
          body: "*"
      }
      additional_bindings36 {
        delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/annotations"
          body: "*"
      }
      additional_bindings37 {
        delete: "/v2/annotations"
          body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Delete;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get; // for cleaning up some optimizations we have in DB layer for annotations.
  }

  // Execute a search over annotation
  rpc PostAnnotationsSearches(PostAnnotationsSearchesRequest) returns (MultiSearchResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/annotations/searches"
      body: "*"
      additional_bindings38 {
        post: "/v2/annotations/searches"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Search;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get; // to know the concepts and models in your default workflow.

  }

  ////////////////////////////////////////
  // Inputs
  ////////////////////////////////////////

  // Get input count per status.
  rpc GetInputCount (GetInputCountRequest) returns (SingleInputCountResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/inputs/status"
      additional_bindings39 {
        get: "/v2/inputs/status"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
  }

  // Streams all the inputs starting from oldest assets.
  rpc StreamInputs (StreamInputsRequest) returns (MultiInputResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/inputs/stream"
      additional_bindings40 {
        get: "/v2/inputs/stream"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
  }

  // Get a specific input from an app.
  rpc GetInputSamples (GetInputSamplesRequest) returns (MultiInputAnnotationResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/tasks/{task_id}/inputs/samples"
      additional_bindings41 {
        get: "/v2/tasks/{task_id}/inputs/samples"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
  }

  // Get a specific input from an app.
  rpc GetInput (GetInputRequest) returns (SingleInputResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/inputs/{input_id}"
      additional_bindings42 {
        get: "/v2/inputs/{input_id}"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
  }

  // List all the inputs.
  rpc ListInputs (ListInputsRequest) returns (MultiInputResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/inputs"
      additional_bindings43 {
        get: "/v2/inputs"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
  }

  // Add an input (or set of inputs) to an app.
  // This call is synchronous if the PostInputsRequest contains exactly one image input. Otherwise,
  // it is asynchronous.
  rpc PostInputs (PostInputsRequest) returns (MultiInputResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/inputs"
      body: "*"
      additional_bindings44 {
        post: "/v2/inputs"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Predict;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
  }

  // Add an input (or set of inputs) to an app via a file.
  // This is asynchronous.
  rpc PostInputsFile (PostInputsFileRequest) returns (MultiInputResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/inputs/file"
      body: "*"
      additional_bindings45 {
        post: "/v2/inputs/file"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Add;
  }

  // Add an input or set of inputs to an app designed for NiFi integration.
  rpc PostInputsNiFi (PostInputsNiFiRequest) returns (MultiInputResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/vendors/nifi/inputs"
      body: "*"
      additional_bindings46 {
        post: "/v2/vendors/nifi/inputs"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Add;
  }

  // Add an input or set of inputs to an app designed for Document integration.
  rpc PostInputsDocument (PostInputsDocumentRequest) returns (MultiInputResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/vendors/document/inputs"
      body: "body"
      additional_bindings47 {
        post: "/v2/vendors/document/inputs"
        body: "body"
      }
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Add;
  }

  // Patch one or more inputs.
  rpc PatchInputs (PatchInputsRequest) returns (MultiInputResponse) {
    option (google.api.http) = {
      patch: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/inputs"
      body: "*"
      additional_bindings48 {
        patch: "/v2/inputs"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
  }

  // Delete a single input asynchronously.
  rpc DeleteInput (DeleteInputRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/inputs/{input_id}"
      additional_bindings49 {
        delete: "/v2/inputs/{input_id}"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Delete;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Delete;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
  }

  // Delete multiple inputs in one request.
  // This call is asynchronous.
  rpc DeleteInputs (DeleteInputsRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/inputs"
      body: "*"
      additional_bindings50 {
        delete: "/v2/inputs"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Delete;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Delete;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
  }

  // Execute a search over input
  rpc PostInputsSearches(PostInputsSearchesRequest) returns (MultiSearchResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/inputs/searches"
      body: "*"
      additional_bindings51 {
        post: "/v2/inputs/searches"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Search;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get; // to know the concepts and models in your default workflow.
  }

  // Get predicted outputs from the model.
  rpc PostModelOutputs (PostModelOutputsRequest) returns (MultiOutputResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/versions/{version_id}/outputs"
      body: "*"
      additional_bindings52 {
        post: "/v2/models/{model_id}/versions/{version_id}/outputs"
        body: "*"
      }
      additional_bindings53 {
        post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/outputs"
        body: "*"
      }
      additional_bindings54 {
        post: "/v2/models/{model_id}/outputs"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Predict;
  }

  ////////////////////////////////////////

  ////////////////////////////////////////
  // Models
  ////////////////////////////////////////

  // Get a specific model type.
  rpc GetModelType (GetModelTypeRequest) returns (SingleModelTypeResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/types/{model_type_id}"
      additional_bindings55 {
        get: "/v2/models/types/{model_type_id}"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
  }

  // List all the model types available in the platform.
  // This MUST be above ListModels so that the /models/types endpoint takes precedence.
  rpc ListModelTypes (ListModelTypesRequest) returns (MultiModelTypeResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/types"
      additional_bindings56 {
        get: "/v2/models/types"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
  }

  // Get a specific model from an app.
  rpc GetModel (GetModelRequest) returns (SingleModelResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}"
      additional_bindings57 {
        get: "/v2/models/{model_id}"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
  }

  // Get a the output info for a given model_id or model_id/version_id
  // combo.
  rpc GetModelOutputInfo (GetModelRequest) returns (SingleModelResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/output_info"
      additional_bindings58 {
        get: "/v2/models/{model_id}/output_info"
      }
      additional_bindings59 {
        get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/versions/{version_id}/output_info"
      }
      additional_bindings60 {
        get: "/v2/models/{model_id}/versions/{version_id}/output_info"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
  }

  // List all the models.
  rpc ListModels (ListModelsRequest) returns (MultiModelResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models"
      additional_bindings61 {
        get: "/v2/models"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
  }


  // Search over the models to find one or more you're looking for.
  // This leverage the "body" parameter because we also have page and
  // per_page as url query param variables in this request.
  rpc PostModelsSearches (PostModelsSearchesRequest) returns (MultiModelResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/searches"
      body: "*"
      additional_bindings62 {
        post: "/v2/models/searches"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
  }

  // Add a models to an app.
  // FIXME(zeiler): this should have been a plural response.
  rpc PostModels (PostModelsRequest) returns (SingleModelResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models"
      body: "*"
      additional_bindings63 {
        post: "/v2/models"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Train;  // Train is needed because it creates a new version.
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get; // Needs to check the base workflow to build off of.
  }

  // Patch one or more models.
  rpc PatchModels (PatchModelsRequest) returns (MultiModelResponse) {
    option (google.api.http) = {
      patch: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models"
      body: "*"
      additional_bindings64 {
        patch: "/v2/models"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Train;
  }

  // Delete a single model.
  rpc DeleteModel (DeleteModelRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}"
      additional_bindings65 {
        delete: "/v2/models/{model_id}"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Delete;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
  }

  // Delete multiple models in one request.
  rpc DeleteModels (DeleteModelsRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models"
      body: "*"
      additional_bindings66 {
        delete: "/v2/models"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Delete;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
  }

  // List all the inputs.
  rpc ListModelInputs (ListModelInputsRequest) returns (MultiInputResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/inputs"
      additional_bindings67 {
        get: "/v2/models/{model_id}/inputs"
      }
      additional_bindings68 {
        get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/versions/{version_id}/inputs"
      }
      additional_bindings69 {
        get: "/v2/models/{model_id}/versions/{version_id}/inputs"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
  }
  ////////////////////////////////////////

  ////////////////////////////////////////
  // Model versions
  ////////////////////////////////////////

  // Get a specific model from an app.
  rpc GetModelVersion (GetModelVersionRequest) returns (SingleModelVersionResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/versions/{version_id}"
      additional_bindings70 {
        get: "/v2/models/{model_id}/versions/{version_id}"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
  }

  // List all the models.
  rpc ListModelVersions (ListModelVersionsRequest) returns (MultiModelVersionResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/versions"
      additional_bindings71 {
        get: "/v2/models/{model_id}/versions"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
  }

  // NOTE: inconsistency: do we want this to return a SingleModelResponse?

  // Create a new model version to trigger training of the model.
  // FIXME(zeiler): this should have been a plural response.
  rpc PostModelVersions (PostModelVersionsRequest) returns (SingleModelResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/versions"
      body: "*"
      additional_bindings72 {
        post: "/v2/models/{model_id}/versions"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Train;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get; // Needs to check the base workflow to build off of.
    option (clarifai.auth.util.cl_depending_scopes) = Metrics_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Metrics_Add;
  }

  rpc PatchModelVersions (PatchModelVersionsRequest) returns (MultiModelVersionResponse) {
    option (google.api.http) = {
      patch: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/versions"
      body: "*"
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Train;
  }

  // Delete a single model.
  rpc DeleteModelVersion (DeleteModelVersionRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/versions/{version_id}"
      additional_bindings73 {
        delete: "/v2/models/{model_id}/versions/{version_id}"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Delete;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
  }

  // Get the evaluation metrics for a model version.
  rpc GetModelVersionMetrics (GetModelVersionMetricsRequest) returns (SingleModelVersionResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/versions/{version_id}/metrics"
      additional_bindings74 {
        get: "/v2/models/{model_id}/versions/{version_id}/metrics"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Metrics_Get;
  }

  // Run the evaluation metrics for a model version.
  rpc PostModelVersionMetrics (PostModelVersionMetricsRequest) returns (SingleModelVersionResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/models/{model_id}/versions/{version_id}/metrics"
      body: "*"
      additional_bindings75 {
        post: "/v2/models/{model_id}/versions/{version_id}/metrics"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Train;
    option (clarifai.auth.util.cl_depending_scopes) = Predict;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get; // Needs to check the base workflow to build off of.
    option (clarifai.auth.util.cl_depending_scopes) = Metrics_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Metrics_Add;
  }

  ////////////////////////////////////////


  ////////////////////////////////////////
  // Workflows
  ////////////////////////////////////////

  // Get a specific workflow from an app.
  rpc GetWorkflow (GetWorkflowRequest) returns (SingleWorkflowResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/workflows/{workflow_id}"
      additional_bindings76 {
        get: "/v2/workflows/{workflow_id}"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
  }

  // List all the workflows.
  rpc ListWorkflows (ListWorkflowsRequest) returns (MultiWorkflowResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/workflows"
      additional_bindings77 {
        get: "/v2/workflows"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
  }

  // FIXME(zeiler): deprecate this whole endpoint.
  // List all public workflows.
  rpc ListPublicWorkflows (ListPublicWorkflowsRequest) returns (MultiWorkflowResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/public_workflows"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = SessionTokenAuth;
  }

  // Add a workflow to an app.
  rpc PostWorkflows (PostWorkflowsRequest) returns (MultiWorkflowResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/workflows"
      body: "*"
      additional_bindings78 {
        post: "/v2/workflows"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
  }

  // Patch one or more workflows.
  rpc PatchWorkflows (PatchWorkflowsRequest) returns (MultiWorkflowResponse) {
    option (google.api.http) = {
      patch: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/workflows"
      body: "*"
      additional_bindings79 {
        patch: "/v2/workflows"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
  }

  // Delete a single workflow.
  rpc DeleteWorkflow (DeleteWorkflowRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/workflows/{workflow_id}"
      additional_bindings80 {
        delete: "/v2/workflows/{workflow_id}"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Delete;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
  }

  // Delete multiple workflows in one request.
  rpc DeleteWorkflows (DeleteWorkflowsRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/workflows"
      body: "*"
      additional_bindings81 {
        delete: "/v2/workflows"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Delete;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
  }

  // Predict using a workflow.
  rpc PostWorkflowResults (PostWorkflowResultsRequest) returns (PostWorkflowResultsResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/workflows/{workflow_id}/results"
      body: "*"
      additional_bindings82 {
        post: "/v2/workflows/{workflow_id}/results"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Predict;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
  }

  // Compare embeddings distances using a workflow

  rpc PostWorkflowResultsSimilarity(PostWorkflowResultsSimilarityRequest) returns (PostWorkflowResultsSimilarityResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/workflows/{workflow_id}/results/similarity"
      body: "*"
      additional_bindings83 {
        post: "/v2/workflows/{workflow_id}/results/similarity"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Predict;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
  }
  ////////////////////////////////////////

  ////////////////////////////////////////
  // Workflow Operators
  ////////////////////////////////////////

  // Get a specific operator type.
  rpc GetOperatorType (GetOperatorTypeRequest) returns (SingleOperatorTypeResponse) {
    option (google.api.http) = {
      get: "/v2/workflows/operators/types/{operator_type_id}"
    };

    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
  }

  // List all the operators types available in the platform.
  rpc ListOperatorTypes (ListOperatorTypesRequest) returns (MultiOperatorTypeResponse) {
    option (google.api.http) = {
      get: "/v2/workflows/operators/types"
    };

    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
  }

  ////////////////////////////////////////

  ////////////////////////////////////////
  // Workflow Metrics
  ////////////////////////////////////////

  // Evaluate all the nodes in the workflow.
  rpc PostWorkflowMetrics (PostWorkflowMetricsRequest) returns (MultiWorkflowMetricsResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/workflows/{workflow_id}/metrics"
      body: "*"
      additional_bindings84 {
        post: "/v2/workflows/{workflow_id}/metrics"
        body: "*"
      }
    };

    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Metrics_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Metrics_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Predict;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
    option (clarifai.auth.util.cl_depending_scopes) = WorkflowMetrics_Get;
    option (clarifai.auth.util.cl_depending_scopes) = WorkflowMetrics_Add;
  }

  // Get workflow evaluation data.
  rpc GetWorkflowMetrics (GetWorkflowMetricsRequest) returns (SingleWorkflowMetricsResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/workflows/{workflow_id}/metrics/{metrics_id}"
      additional_bindings85 {
        get: "/v2/workflows/{workflow_id}/metrics/{metrics_id}"
      }
    };

    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
    option (clarifai.auth.util.cl_depending_scopes) = WorkflowMetrics_Get;
  }

  rpc GetWorkflowNodeMetrics (GetWorkflowNodeMetricsRequest) returns (SingleWorkflowNodeMetricsResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/workflows/{workflow_id}/metrics/{metrics_id}/nodes/{node_id}"
      additional_bindings86 {
        get: "/v2/workflows/{workflow_id}/metrics/{metrics_id}/nodes/{node_id}"
      }
    };

    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
    option (clarifai.auth.util.cl_depending_scopes) = WorkflowMetrics_Get;
  }

  rpc ListWorkflowMetrics (ListWorkflowMetricsRequest) returns (MultiWorkflowMetricsResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/workflows/{workflow_id}/metrics"
      additional_bindings87 {
        get: "/v2/workflows/{workflow_id}/metrics"
      }
    };

    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
    option (clarifai.auth.util.cl_depending_scopes) = WorkflowMetrics_Get;
  }

  // Delete one or more workflow metrics.
  rpc DeleteWorkflowMetrics (DeleteWorkflowMetricsRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/workflows/{workflow_id}/metrics"
      body: "*"
      additional_bindings88 {
        delete: "/v2/workflows/{workflow_id}/metrics"
        body: "*"
      }
    };

    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
    option (clarifai.auth.util.cl_depending_scopes) = WorkflowMetrics_Delete;
    option (clarifai.auth.util.cl_depending_scopes) = WorkflowMetrics_Add;
    option (clarifai.auth.util.cl_depending_scopes) = WorkflowMetrics_Get;
  }

  ////////////////////////////////////////
  // API Keys
  ////////////////////////////////////////

  // Get a specific key from an app.
  rpc GetKey (GetKeyRequest) returns (SingleKeyResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/keys/{key_id}"
    };
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Keys_Get;
  }

  // List all the keys.
  rpc ListKeys (ListKeysRequest) returns (MultiKeyResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/keys"
    };
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Keys_Get;
  }

  // List keys by app_id
  rpc ListAppKeys (ListAppKeysRequest) returns (MultiKeyResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/keys"
    };
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Keys_Get;
  }

  // Search over the keys to find one or more you're looking for.
  // This leverage the "body" parameter because we also have page and
  // per_page as url query param variables in this request.
  rpc DeleteKey (DeleteKeyRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/keys/{key_id}"
    };
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Keys_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Keys_Delete;
    option (clarifai.auth.util.cl_depending_scopes) = Keys_Get;
  }

  // Add a key to an app.
  rpc PostKeys (PostKeysRequest) returns (MultiKeyResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/keys"
      body: "*"
    };
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Keys_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Keys_Get;
  }

  // Patch one or more keys.
  rpc PatchKeys (PatchKeysRequest) returns (MultiKeyResponse) {
    option (google.api.http) = {
      patch: "/v2/users/{user_app_id.user_id}/keys"
      body: "*"
    };
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Keys_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Keys_Get;
  }

  // API Keys in the public API -- request is itself Key authorized, and will tell
  // the user the scopes/access of the key/credential they're providing, as computed by
  // our authorizer:
  rpc MyScopes (MyScopesRequest) returns (MultiScopeResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/myscopes"
      additional_bindings89 {
        get: "/v2/myscopes"
      }
      additional_bindings90 {
        get: "/v2/my_scopes"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
  }

  // List all auth scopes available to me as a user.
  rpc ListScopes (ListScopesRequest) returns (MultiScopeDepsResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/scopes"
    };
    option (clarifai.auth.util.cl_auth_type) = SessionTokenAuth;
  }

  ////////////////////////////////////////
  // Apps
  ////////////////////////////////////////

  // Get a specific app from an app.
  rpc GetApp (GetAppRequest) returns (SingleAppResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}"
    };
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
  }

  // List all the apps.
  rpc ListApps (ListAppsRequest) returns (MultiAppResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps"
      additional_bindings91 {
        get: "/v2/apps"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
  }

  // Search over the apps to find one or more you're looking for.
  // This leverage the "body" parameter because we also have page and
  // per_page as url query param variables in this request.
  rpc DeleteApp (DeleteAppRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}"
    };
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Delete;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
  }

  // Add a app to an app.
  // This needs to load the default workflow to make a copy, validating all the models in it, and
  // then writing the new workflow back to this new app.
  rpc PostApps (PostAppsRequest) returns (MultiAppResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps"
      body: "*"
    };
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Add;
  }

  // Patch one or more apps.
  rpc PatchApps (PatchAppsRequest) returns (MultiAppResponse) {
    option (google.api.http) = {
      patch: "/v2/users/{user_app_id.user_id}/apps"
      body: "*"
    };
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    // option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    // option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
  }

  // Search over the applications to find one or more you're looking for.
  rpc PostAppsSearches (PostAppsSearchesRequest) returns (MultiAppResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/searches"
      body: "*"
    };
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
  }

  ////////////////////////////////////////

  ////////////////////////////////////////
  // Users
  ////////////////////////////////////////

  // Get current user information
  rpc GetUser (GetUserRequest) returns (SingleUserResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
  }

  // List users
  rpc ListUsers (ListUsersRequest) returns (MultiUserResponse) {
    option (google.api.http) = {
      get: "/v2/users"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
  }

  // Update gdpr fields of current user.
  rpc PostUserConsent (PostUserConsentRequest) returns (SingleUserResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/consent"
      body: "*"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = SessionTokenAuth;
  }

  // Patch information of current user or another user in the same organisation
  rpc PatchUser (PatchUserRequest) returns (SingleUserResponse) {
    option (google.api.http) = {
      patch: "/v2/users/{user_app_id.user_id}"
      body: "*"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = SessionTokenAuth;
  }

  ////////////////////////////////////////

  ////////////////////////////////////////
  // Email
  ////////////////////////////////////////
  // Add Email
  rpc PostEmails (PostEmailsRequest) returns (MultipleEmailResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/emails"
      body: "*"
      additional_bindings92 {
        post: "/v2/emails"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = SessionTokenAuth;
  }

  // List emails
  rpc ListEmails (ListEmailsRequest) returns (MultipleEmailResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/emails"
      additional_bindings: {
        get: "/v2/emails"
      }
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = SessionTokenAuth;
  }

  // For sending another verification email.
  rpc PostResendVerifyEmail (PostResendVerifyRequest) returns (SingleResendVerifyResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/resend_verification"
      body: "*"
      additional_bindings93 {
        post: "/v2/resend_verification"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = SessionTokenAuth;
  }

  // Deleting an email.
  rpc DeleteEmail (DeleteEmailRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/emails/{email}"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = SessionTokenAuth;
  }

  // Create primate email.
  rpc PostPrimaryEmail (PostPrimaryEmailRequest) returns (SingleEmailResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/emails/primary"
      body: "*"
      additional_bindings94 {
        post: "/v2/emails/primary"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = SessionTokenAuth;
  }

  ////////////////////////////////////////

  ////////////////////////////////////////
  // Password
  ////////////////////////////////////////

  // Validate new password in real-time for a user
  rpc PostValidatePassword (PostValidatePasswordRequest) returns (SinglePasswordValidationResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/validate_password"
      body: "*"
      additional_bindings95 {
        post: "/v2/validate_password"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = PasswordPolicies_Get;
  }

  ////////////////////////////////////////

  ////////////////////////////////////////
  // Password Policy
  ////////////////////////////////////////

  // Get global policy
  rpc ListGlobalPasswordPolicies (ListGlobalPasswordPoliciesRequest) returns (MultiplePasswordPoliciesResponse) {
    option (google.api.http) = {
      get: "/v2/password_policies/global"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = NoAuth;
  }

  // Get a specific set of password policies attached to a user.
  rpc ListPasswordPolicies (ListPasswordPoliciesRequest) returns (MultiplePasswordPoliciesResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/password_policies"
      additional_bindings96 {
        get: "/v2/password_policies"
      }
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = PasswordPolicies_Get;
  }

  // Create a specific set of password policies attached to a user or an organization.
  rpc PostPasswordPolicies (PostPasswordPoliciesRequest) returns (MultiplePasswordPoliciesResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/password_policies"
      body: "*"
      additional_bindings97 {
        post: "/v2/password_policies"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = PasswordPolicies_Add;
    option (clarifai.auth.util.cl_depending_scopes) = PasswordPolicies_Get;
  }

  // Update a specific set of password policies attached to a user or an organization.
  rpc PatchPasswordPolicies (PatchPasswordPoliciesRequest) returns (MultiplePasswordPoliciesResponse) {
    option (google.api.http) = {
      patch: "/v2/users/{user_app_id.user_id}/password_policies"
      body: "*"
      additional_bindings98 {
        patch: "/v2/password_policies"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = PasswordPolicies_Add;
    option (clarifai.auth.util.cl_depending_scopes) = PasswordPolicies_Get;
  }

  rpc DeletePasswordPolicies (DeletePasswordPoliciesRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/password_policies"
      additional_bindings99 {
        delete: "/v2/password_policies"
      }
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = PasswordPolicies_Add;
    option (clarifai.auth.util.cl_depending_scopes) = PasswordPolicies_Delete;
    option (clarifai.auth.util.cl_depending_scopes) = PasswordPolicies_Get;
  }

  ////////////////////////////////////////

  ////////////////////////////////////////
  // User features
  ////////////////////////////////////////

  // Get user feature config
  rpc GetUserFeatureConfig (UserFeatureConfigRequest) returns (SingleUserFeatureConfigResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/feature_flags"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = UserFeatureConfigs_Get;
  }
  ////////////////////////////////////////

  ////////////////////////////////////////

  ////////////////////////////////////////
  // Organizations
  ////////////////////////////////////////

  // Add organizations
  rpc PostOrganizations (PostOrganizationsRequest) returns (MultiOrganizationResponse) {
    option (google.api.http) = {
      post: "/v2/organizations"
      body: "*"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Organizations_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Organizations_Get;
  }

  // List the provided user's organizations with their roles
  rpc ListUsersOrganizations (ListUsersOrganizationsRequest) returns (MultiUsersOrganizationsResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/organizations"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = UserOrganizations_Get;
  }

  // List multiple organizations
  rpc ListOrganizations (ListOrganizationsRequest) returns (MultiOrganizationResponse) {
    option (google.api.http) = {
      get: "/v2/organizations"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Organizations_Get;
  }

  // Get single organization
  rpc GetOrganization (GetOrganizationRequest) returns (SingleOrganizationResponse) {
    option (google.api.http) = {
      get: "/v2/organizations/{user_app_id.user_id}"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Organizations_Get;
  }

  // Patch an organization
  rpc PatchOrganization (PatchOrganizationRequest) returns (SingleOrganizationResponse) {
    option (google.api.http) = {
      patch: "/v2/organizations/{user_app_id.user_id}"
      body: "*"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Organizations_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Organizations_Get;
  }

  // Delete an organization
  rpc DeleteOrganization (DeleteOrganizationRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/organizations/{user_app_id.user_id}"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Organizations_Delete;
    option (clarifai.auth.util.cl_depending_scopes) = Organizations_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Organizations_Get;
  }

  ////////////////////////////////////////
  // List organization members
  rpc ListOrganizationMembers (ListOrganizationMembersRequest) returns (MultiOrganizationMemberResponse) {
    option (google.api.http) = {
      get: "/v2/organizations/{user_app_id.user_id}/members"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = OrganizationMembers_List;
  }

  // Add new member to organization
  rpc PostOrganizationMember (PostOrganizationMemberRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      post: "/v2/organizations/{user_app_id.user_id}/members"
      body: "*"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = OrganizationMembers_Add;
  }


  rpc PatchOrganizationMember (PatchOrganizationMembersRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      patch: "/v2/organizations/{user_app_id.user_id}/members"
      body: "*"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = OrganizationMembers_Add;
  }

  // Remove a member from organization
  rpc DeleteOrganizationMember (DeleteOrganizationMemberRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/organizations/{user_app_id.user_id}/members/{member_id}"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = OrganizationMembers_Delete;
  }

  //org invites
  rpc PostOrganizationInvitations (PostOrganizationInvitationsRequest) returns (MultiOrganizationInvitationResponse) {
    option (google.api.http) = {
      post: "/v2/organizations/{user_app_id.user_id}/invitations"
      body: "*"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = OrganizationInvitations_Add;
  }

  rpc PatchOrganizationInvitations (PatchOrganizationInvitationsRequest) returns (MultiOrganizationInvitationResponse) {
    option (google.api.http) = {
      patch: "/v2/organizations/{user_app_id.user_id}/invitations"
      body: "*"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = OrganizationInvitations_Add;
  }

  rpc ListOrganizationInvitations (ListOrganizationInvitationsRequest) returns (MultiOrganizationInvitationResponse) {
    option (google.api.http) = {
      get: "/v2/organizations/{user_app_id.user_id}/invitations"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = OrganizationInvitations_Get;
  }

  rpc GetOrganizationInvitation (GetOrganizationInvitationRequest) returns (SingleOrganizationInvitationResponse) {
    option (google.api.http) = {
      get: "/v2/organizations/{user_app_id.user_id}/invitations/{id}"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = OrganizationInvitations_Get;
  }

  rpc PostDeclineOrganizationInvitation (PostDeclineOrganizationInvitationRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/organization_invitation_decline/{id}"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = SessionTokenAuth;
  }

  rpc PostAcceptOrganizationInvitation (PostAcceptOrganizationInvitationRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/organization_invitation_accept/{id}"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = SessionTokenAuth;
  }

  rpc GetOrganizationInvitationPublic (GetOrganizationInvitationPublicRequest) returns (SingleOrganizationInvitationResponse) {
    option (google.api.http) = {
      get: "/v2/organization_invitation/{id}"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = NoAuth;
  }

  // Leave an organization
  rpc DeleteRequestingUserFromOrganization (DeleteRequestingUserFromOrganizationRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/organizations/{user_app_id.user_id}/leave"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
  }

  ////////////////////////////////////////
  // IdentityProviders
  ////////////////////////////////////////

  // Add IdentityProviders
  rpc PostIdentityProviders (PostIdentityProvidersRequest) returns (MultiIdentityProviderResponse) {
    option (google.api.http) = {
      post: "/v2/organizations/{user_app_id.user_id}/identity_providers"
      body: "*"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = IdentityProviders_Add;
    option (clarifai.auth.util.cl_depending_scopes) = IdentityProviders_Get;
  }

  // List multiple IdentityProviders
  rpc ListIdentityProviders (ListIdentityProvidersRequest) returns (MultiIdentityProviderResponse) {
    option (google.api.http) = {
      get: "/v2/organizations/{user_app_id.user_id}/identity_providers"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = IdentityProviders_Get;
  }

  // Get single IdentityProvider
  rpc GetIdentityProvider (GetIdentityProviderRequest) returns (SingleIdentityProviderResponse) {
    option (google.api.http) = {
      get: "/v2/organizations/{user_app_id.user_id}/identity_providers/{id}"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = IdentityProviders_Get;
  }

  // Patch multiple IdentityProviders
  rpc PatchIdentityProviders (PatchIdentityProvidersRequest) returns (MultiIdentityProviderResponse) {
    option (google.api.http) = {
      patch: "/v2/organizations/{user_app_id.user_id}/identity_providers"
      body: "*"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = IdentityProviders_Add;
    option (clarifai.auth.util.cl_depending_scopes) = IdentityProviders_Get;
  }

  // Delete multiple IdentityProviders
  rpc DeleteIdentityProviders (DeleteIdentityProvidersRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/organizations/{user_app_id.user_id}/identity_providers"
      body: "*"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = IdentityProviders_Delete;
    option (clarifai.auth.util.cl_depending_scopes) = IdentityProviders_Add;
    option (clarifai.auth.util.cl_depending_scopes) = IdentityProviders_Get;
  }

  ////////////////////////////////////////

  ////////////////////////////////////////
  // Teams
  ////////////////////////////////////////

  // Add teams
  rpc PostTeams (PostTeamsRequest) returns (MultiTeamResponse) {
    option (google.api.http) = {
      post: "/v2/organizations/{user_app_id.user_id}/teams"
      body: "*"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Teams_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Teams_Get;
  }

  // List multiple teams
  rpc ListTeams (ListTeamsRequest) returns (MultiTeamResponse) {
    option (google.api.http) = {
      get: "/v2/organizations/{user_app_id.user_id}/teams"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Teams_Get;
  }

  // Get single team
  rpc GetTeam (GetTeamRequest) returns (SingleTeamResponse) {
    option (google.api.http) = {
      get: "/v2/organizations/{user_app_id.user_id}/teams/{id}"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Teams_Get;
  }

  // Patch multiple teams
  rpc PatchTeams (PatchTeamsRequest) returns (MultiTeamResponse) {
    option (google.api.http) = {
      patch: "/v2/organizations/{user_app_id.user_id}/teams"
      body: "*"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Teams_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Teams_Get;
  }

  // Delete multiple teams
  rpc DeleteTeams (DeleteTeamsRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/organizations/{user_app_id.user_id}/teams"
      body: "*"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Teams_Delete;
    option (clarifai.auth.util.cl_depending_scopes) = Teams_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Teams_Get;
  }


  // Add users to a team
  rpc PostTeamUsers (PostTeamUsersRequest) returns (MultiTeamUserResponse) {
    option (google.api.http) = {
      post: "/v2/organizations/{user_app_id.user_id}/teams/{team_id}/users"
      body: "*"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = TeamUsers_Add;
    option (clarifai.auth.util.cl_depending_scopes) = TeamUsers_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Teams_Get;
  }

  // List team users
  rpc ListTeamUsers (ListTeamUsersRequest) returns (MultiTeamUserResponse) {
    option (google.api.http) = {
      get: "/v2/organizations/{user_app_id.user_id}/teams/{team_id}/users"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = TeamUsers_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Teams_Get;
  }

  // Delete users from a team
  rpc DeleteTeamUsers (DeleteTeamUsersRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/organizations/{user_app_id.user_id}/teams/{team_id}/users"
      body: "*"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = TeamUsers_Delete;
    option (clarifai.auth.util.cl_depending_scopes) = TeamUsers_Add;
    option (clarifai.auth.util.cl_depending_scopes) = TeamUsers_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Teams_Get;
  }

  // Add applications to team
  rpc PostTeamApps(PostTeamAppsRequest) returns(clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      post: "/v2/organizations/{user_app_id.user_id}/teams/{team_id}/apps"
      body: "*"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = TeamApps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = TeamApps_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Teams_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Roles_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
  }

  // List team applications
  rpc ListTeamApps(ListTeamAppsRequest) returns(MultiTeamAppsResponse) {
    option (google.api.http) = {
      get: "/v2/organizations/{user_app_id.user_id}/teams/{team_id}/apps"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = TeamApps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Teams_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Roles_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
  }

  // Remove applications from team
  rpc DeleteTeamApps(DeleteTeamAppsRequest) returns(clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/organizations/{user_app_id.user_id}/teams/{team_id}/apps"
      body: "*"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = TeamApps_Delete;
    option (clarifai.auth.util.cl_depending_scopes) = TeamApps_Get;
    option (clarifai.auth.util.cl_depending_scopes) = TeamApps_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Teams_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Roles_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Apps_Get;
  }
  ////////////////////////////////////////

  ////////////////////////////////////////
  // Roles
  ////////////////////////////////////////

  // List multiple roles
  rpc ListRoles (ListRolesRequest) returns (MultiRoleResponse) {
    option (google.api.http) = {
      get: "/v2/roles"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Roles_Get;
  }

  // Get single role
  rpc GetRole (GetRoleRequest) returns (SingleRoleResponse) {
    option (google.api.http) = {
      get: "/v2/roles/{id}"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = PATAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Roles_Get;
  }

  ////////////////////////////////////////
  // Searches
  ////////////////////////////////////////

  // Get a saved search.
  rpc GetSearch (GetSearchRequest) returns (SingleSearchResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/searches/{id}"
      additional_bindings100 {
        get: "/v2/searches/{id}"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Search;
  }

  // List all saved searches.
  rpc ListSearches (ListSearchesRequest) returns (MultiSearchResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/searches"
      additional_bindings101 {
        get: "/v2/searches"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Search;
  }

  // Execute a new search and optionally save it.
  rpc PostSearches (PostSearchesRequest) returns (MultiSearchResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/searches"
      body: "*"
      additional_bindings102 {
        post: "/v2/searches"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    // option (clarifai.auth.util.cl_depending_scopes) = Predict; // optional
    option (clarifai.auth.util.cl_depending_scopes) = Search;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get; // to know the concepts and models in your default workflow.
  }

  // Execute a previously saved search.
  rpc PostSearchesByID (PostSearchesByIDRequest) returns (MultiSearchResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/searches/{id}"
      body: "*"
      additional_bindings103 {
        post: "/v2/searches/{id}"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Search;
  }

  // Evaluate the results of two search requests
  rpc PostAnnotationSearchMetrics(PostAnnotationSearchMetricsRequest) returns (MultiAnnotationSearchMetricsResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/annotations/searches/metrics"
      body: "*"
      additional_bindings104 {
        post: "/v2/annotations/searches/metrics"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Metrics_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Metrics_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get; // as it needs to know the concepts in your workflow's models.
  }

  // Get the evaluation results between two search requests
  rpc GetAnnotationSearchMetrics(GetAnnotationSearchMetricsRequest) returns (MultiAnnotationSearchMetricsResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/annotations/searches/metrics/{id}"
      additional_bindings105 {
        get: "/v2/annotations/searches/metrics/{id}"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Metrics_Get;
  }


  // List the evaluation results between two search requests
  rpc ListAnnotationSearchMetrics(ListAnnotationSearchMetricsRequest) returns (MultiAnnotationSearchMetricsResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/annotations/searches/metrics"
      additional_bindings106 {
        get: "/v2/annotations/searches/metrics"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Metrics_Get;
  }

  rpc DeleteAnnotationSearchMetrics (DeleteAnnotationSearchMetricsRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/annotations/searches/metrics/{id}"
      additional_bindings107 {
        delete: "/v2/annotations/searches/metrics/{id}"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Metrics_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Metrics_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Metrics_Delete;
  }

  // Delete a saved search.
  rpc DeleteSearch (DeleteSearchRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/searches/{id}"
      additional_bindings108 {
        delete: "/v2/searches/{id}"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Search;
  }

  // Execute an attribute search.
  rpc PostAttributeSearch (PostAttributeSearchRequest) returns (MultiSearchResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/attribute_searches"
      body: "*"
      additional_bindings109 {
        post: "/v2/attribute_searches"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    // option (clarifai.auth.util.cl_depending_scopes) = Predict; // optional
    option (clarifai.auth.util.cl_depending_scopes) = Search;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get; // to know the concepts and models in your default workflow.
  }

  // Get a list of clusters in an app
  rpc ListClusters (ListClustersRequest) returns (MultiClusterResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/clusters"
      additional_bindings110 {
        get: "/v2/clusters"
      }
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Search;
  }

  // List all the annotations for a given cluster.
  rpc ListAnnotationsForCluster (ListAnnotationsForClusterRequest) returns (MultiAnnotationResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/clusters/{cluster_id}/annotations"
      additional_bindings111 {
        get: "/v2/clusters/{cluster_id}/annotations"
      }
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Search;
  }

  // List all the annotations for a given cluser.
  rpc PostClustersSearches (PostClustersSearchesRequest) returns (MultiClusterResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/clusters/searches"
          body: "*"
      additional_bindings112 {
        post: "/v2/clusters/searches"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Search;
  }
  ////////////////////////////////////////


  ////////////////////////////////////////
  // Login
  ////////////////////////////////////////

  // Verify email
  rpc PostVerifyEmail (PostVerifyEmailRequest) returns (SingleVerifyEmailResponse) {
    option (google.api.http) = {
      post: "/v2/verify_email"
      body: "*"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = NoAuth;
  }

  // Request for password reset email
  rpc PostRequestResetPassword (RequestResetPasswordRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
        post: "/v2/request_password_reset"
        body:"*"
        };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = NoAuth;
  }

  // Complete reset password
  rpc PostCompleteResetPassword (CompleteResetPasswordRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      post: "/v2/complete_password_reset"
        body:"*"
        };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = NoAuth;
  }

  // Login with user/pass
  rpc PostLogin (PostLoginRequest) returns (SingleLoginResponse) {
    option (google.api.http) = {
      post: "/v2/login"
      body: "*"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = NoAuth;
  }

  // Signup with account.
  rpc PostSignup (PostSignupRequest) returns (SingleLoginResponse) {
    option (google.api.http) = {
      post: "/v2/signup"
      body: "*"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = NoAuth;
  }

  // Logout use
  rpc PostLogout (PostLogoutRequest) returns (SingleLogoutResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/logout"
      body: "*"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = SessionTokenAuth;
  }

  // List available authentication methods, e.g.
  // * standard auth method - login using user & password
  // * SAML auth methods - SSO using SAML Identity Providers like Okta, Github, Google GSuite, LinkedIn, etc.
  rpc ListAuthMethods (ListAuthMethodsRequest) returns (ListAuthMethodsResponse) {
    option (google.api.http) = {
      get: "/v2/auth/methods"
      additional_bindings: {
        get: "/v2/organizations/{user_app_id.user_id}/auth/methods"
      }
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = NoAuth;
  }

  ////////////////
  // 2FA (Two factor authentication)

  // List available 2FA methods in current environment, e.g.
  // * TOTP auth method - login layer using time synced  codes
  rpc ListAuth2FAMethods (List2FAMethodsRequest) returns (List2FAMethodsResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/auth/2fa/methods"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = SessionTokenAuth;
  }

  // Enable Clarifai TOTP 2FA
  rpc PostAuth2FATotpRegisterEnable (PostAuth2FATotpRegisterEnableRequest) returns (PostAuth2FATotpRegisterEnableResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/auth/2fa/totp/register/enable"
      body: "*"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = SessionTokenAuth;
  }

  // Verify Clarifai TOTP 2FA activation
  rpc PostAuth2FATotpRegisterVerify (PostAuth2FATotpRegisterVerifyRequest) returns (PostAuth2FATotpRegisterVerifyResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/auth/2fa/totp/register/verify",
      body: "*"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = SessionTokenAuth;
  }

  // Disable Clarifai TOTP 2FA
  rpc PostAuth2FATotpDisable (PostAuth2FATotpDisableRequest) returns (PostAuth2FATotpDisableResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/auth/2fa/totp/disable",
      body: "*"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = SessionTokenAuth;
  }


  // Login with Clarifai TOTP 2FA activation
  rpc PostAuth2FATotpLogin (PostAuth2FATotpLoginRequest) returns (SingleLoginResponse) {
    option (google.api.http) = {
      post: "/v2/auth/2fa/totp/login",
      body: "*"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = NoAuth;
  }

  // Recover users Clarifai TOTP 2FA activation through sending an email confirmation.
  rpc PostAuth2FATotpRecover (PostAuth2FATotpRecoverRequest) returns (PostAuth2FATotpRecoverResponse) {
    option (google.api.http) = {
      post: "/v2/auth/2fa/totp/recover",
      body: "*"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = NoAuth;
  }

  // Confirm the recovery of users Clarifai TOTP 2FA. Will be called by user from email link (via portal).
  rpc GetAuth2FATotpRecoverConfirm (GetAuth2FATotpRecoverConfirmRequest) returns (GetAuth2FATotpRecoverConfirmResponse) {
    option (google.api.http) = {
      get: "/v2/auth/2fa/totp/recover/confirm"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = NoAuth;
  }

  ////////////////////////////////////////

  ////////////////////////////////////////
  // Subscriptions
  ////////////////////////////////////////

  // List the subscriptions.
  rpc GetSubscription (GetSubscriptionRequest) returns (SingleSubscriptionResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/subscriptions"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = SessionTokenAuth;
  }

  // Add a new subscription.
  rpc PostSubscription (PostSubscriptionRequest) returns (SingleSubscriptionResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/subscriptions"
      body: "*"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = SessionTokenAuth;
  }

  // List all credit cards.
  rpc ListCreditCards (ListCreditCardsRequest) returns (MultipleCreditCardResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/credit_cards"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = SessionTokenAuth;
  }

  // Add a new credit card.
  rpc PostCreditCard (PostCreditCardRequest) returns (SingleCreditCardResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/credit_cards"
      body: "*"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = SessionTokenAuth;
  }

  // Delete a credit card.
  rpc DeleteCreditCard (DeleteCreditCardRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/credit_cards"
      body: "*"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = SessionTokenAuth;
  }

  // Update a credit card.
  rpc PatchCreditCards (PatchCreditCardsRequest) returns (MultipleCreditCardResponse) {
    option (google.api.http) = {
      patch: "/v2/users/{user_app_id.user_id}/credit_cards"
      body: "*"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = SessionTokenAuth;
  }

  // Get the shipping address.
  rpc GetShippingAddress(GetShippingAddressRequest) returns (SingleShippingAddressResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/shipping_address"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = SessionTokenAuth;
  }

  // Update shipping address.
  rpc PutShippingAddress(PutShippingAddressRequest) returns (SingleShippingAddressResponse) {
    option (google.api.http) = {
      put: "/v2/users/{user_app_id.user_id}/shipping_address"
      body: "*"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = SessionTokenAuth;
  }

  rpc ListPlans(ListPlansRequest) returns (MultiPlanResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/plans"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = SessionTokenAuth;
  }
  ////////////////////////////////////////

  ////////////////////////////////////////
  // Status Codes
  ////////////////////////////////////////

  // List all status codes.
  rpc ListStatusCodes (ListStatusCodesRequest) returns (MultiStatusCodeResponse) {
    option (google.api.http) = {
      get: "/v2/status_codes"
    };
    option (clarifai.auth.util.cl_auth_type) = NoAuth;
  }

  // Get more details for a status code.
  rpc GetStatusCode (GetStatusCodeRequest) returns (SingleStatusCodeResponse) {
    option (google.api.http) = {
      get: "/v2/status_codes/{status_code_id}"
    };
    option (clarifai.auth.util.cl_auth_type) = NoAuth;
  }

  ////////////////////////////////////////
  // Health Check for API
  ////////////////////////////////////////

  // Health check endpoint
  rpc GetHealthz (GetHealthzRequest) returns (GetHealthzResponse) {
    option (google.api.http) = {
      get: "/v2/healthz"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = NoAuth;
  }

  ////////////////////////////////////////
  // Usage Dashboard
  ////////////////////////////////////////

  // List all billing  cycles.
  rpc ListUserBillingCycles (ListUserBillingCyclesRequest) returns (ListUserBillingCyclesResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/billing_cycles"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = SessionTokenAuth;
  }

  // Gets the billing cycle start and end date as well as invoice items.
  rpc GetBillingUsage (GetBillingUsageRequest) returns (GetBillingUsageResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/billing_usage"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = SessionTokenAuth;
  }

  // Add historical usage.
  rpc PostHistoricalUsage (PostHistoricalUsageRequest) returns (PostHistoricalUsageResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/historical_usage"
      body: "*"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = SessionTokenAuth;
  }

  // Get a list of valid usage intervals
  rpc ListUsageIntervals (ListUsageIntervalsRequest) returns (ListUsageIntervalsResponse) {
    option (google.api.http) = {
      get: "/v2/usage_intervals"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = NoAuth;
  }

  // Get realtime usage.
  rpc GetRealtimeUsage (GetRealtimeUsageRequest) returns (GetRealtimeUsageResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/realtime_usage"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = SessionTokenAuth;
  }

  // Post usage to platform. Only called by on prem now.
  rpc PostUsage (PostUsageRequest) returns (PostUsageResponse) {
    // HTTP endpoint should be DELETED after testing.
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/usage"
      body: "*"
      additional_bindings113 {
        post: "/v2/usage"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = All;
  }

  ////////////////////////////////////////
  // App Sharing
  ////////////////////////////////////////

  // owner list users who the app is shared with
  rpc ListCollaborators (ListCollaboratorsRequest) returns (MultiCollaboratorsResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/collaborators"
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Collaborators_Get;
  }

  // add collaborators to an app.
  rpc PostCollaborators (PostCollaboratorsRequest) returns (MultiCollaboratorsResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/collaborators"
      body: "*"
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Collaborators_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Collaborators_Get;
  }

  // Patch existing collaborators.
  rpc PatchCollaborators (PatchCollaboratorsRequest) returns (MultiCollaboratorsResponse) {
    option (google.api.http) = {
      patch: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/collaborators"
      body: "*"
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Collaborators_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Collaborators_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Collaborators_Delete;
  }

  // Delete existing collaborators.
  rpc DeleteCollaborators (DeleteCollaboratorsRequest) returns (clarifai.api.status.BaseResponse){
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/collaborators"
      body: "*"
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Collaborators_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Collaborators_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Collaborators_Delete;
    option (clarifai.auth.util.cl_depending_scopes) = Tasks_Add; // when deleting a collaborator, we also delete task workers associated to this collaborator
    option (clarifai.auth.util.cl_depending_scopes) = Tasks_Get;
  }

  // Collaboration includes the app user are invitied to work on
  rpc ListCollaborations (ListCollaborationsRequest) returns (MultiCollaborationsResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/collaborations"
    };
    option (clarifai.auth.util.cl_auth_type) = SessionTokenAuth;
  }

  ////////////////////////////////////////
  // Licenses
  ////////////////////////////////////////

  // Get the license with crypto security.
  rpc FetchLicense (FetchLicenseRequest) returns (FetchLicenseResponse) {
    option (google.api.http) = {
    post: "/v2/licenses/{license_id}"
    body: "*"
  };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = All;
  }

  // List all licenses.
  rpc ListLicenses (ListLicensesRequest) returns (MultipleLicensesResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/licenses"
      additional_bindings114 {
        get: "/v2/licenses"
      }
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = All;
  }

  // Get a license
  rpc GetLicense (GetLicenseRequest) returns (SingleLicenseResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/licenses/{license_id}"
      additional_bindings115 {
        get: "/v2/licenses/{license_id}"
      }
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = All;
  }

  // Check that a license is still valid.
  rpc ValidateLicense (ValidateLicenseRequest) returns (ValidateLicenseResponse) {
    option (google.api.http) = {
      post: "/v2/licenses/{license_id}/validate"
        body: "*"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = All;
  }

  ////////////////////////////////////////
  // App duplication
  ////////////////////////////////////////

  // start to duplicate an app which copies all the inputs, annotations, models, concepts etc. to a new app.
  // this is an async process, you should use ListAppDuplications or GetAppDuplication to check the status.
  rpc PostAppDuplications (PostAppDuplicationsRequest) returns (MultiAppDuplicationsResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/duplications"
        body: "*"
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Train;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
  }

  // list all the app duplications user triggers
  rpc ListAppDuplications (ListAppDuplicationsRequest) returns (MultiAppDuplicationsResponse){
    option (google.api.http) = {
      get : "/v2/users/{user_app_id.user_id}/duplications"
    };
    option (clarifai.auth.util.cl_auth_type) = SessionTokenAuth;
  }

  // get the app duplication status
  rpc GetAppDuplication (GetAppDuplicationRequest) returns (SingleAppDuplicationResponse) {
    option (google.api.http) = {
      get : "/v2/users/{user_app_id.user_id}/duplications/{app_duplication_id}"
    };
    option (clarifai.auth.util.cl_auth_type) = SessionTokenAuth;
  }

  ////////////////////////////////////////
  // Tasks
  ////////////////////////////////////////

  // Add tasks to an app.
  rpc PostTasks (PostTasksRequest) returns (MultiTaskResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/tasks"
      body: "*"
      additional_bindings116 {
        post: "/v2/tasks"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Tasks_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Tasks_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Search;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get; // needed for converting workers internal ids to external ids
    // option (clarifai.auth.util.cl_depending_scopes) = Predict; // optional, needed for add_task_annotations.go when saved search uses visual search
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Add; // needed for add_task_annotations.go
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get; // needed for add_task_annotations.go
  }

  // Task annotation count
  rpc GetTaskAnnotationCount (GetTaskCountRequest) returns (SingleTaskCountResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/tasks/{task_id}/annotations/count"
      additional_bindings117 {
        get: "/v2/tasks/{task_id}/annotations/count"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Tasks_Get;
  }

  // Task Input count
  rpc GetTaskInputCount (GetTaskCountRequest) returns (SingleTaskCountResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/tasks/{task_id}/inputs/count"
      additional_bindings118 {
        get: "/v2/tasks/{task_id}/inputs/count"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Tasks_Get;
  }

  // Get a specific task from an app.
  rpc GetTask (GetTaskRequest) returns (SingleTaskResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/tasks/{task_id}"
      additional_bindings119 {
        get: "/v2/tasks/{task_id}"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Tasks_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Search;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get; // needed for converting workers internal ids to external ids
  }

  // List tasks from an app.
  rpc ListTasks (ListTasksRequest) returns (MultiTaskResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/tasks"
      additional_bindings120 {
        get: "/v2/tasks"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Tasks_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Search;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get; // needed for converting workers internal ids to external ids
  }

  // Patch one or more tasks.
  rpc PatchTasks (PatchTasksRequest) returns (MultiTaskResponse) {
    option (google.api.http) = {
      patch: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/tasks"
      body: "*"
      additional_bindings121 {
        patch: "/v2/tasks"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Tasks_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Tasks_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Search;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get; // needed for converting workers internal ids to external ids
    // option (clarifai.auth.util.cl_depending_scopes) = Predict; // optional, needed for add_task_annotations.go when saved search uses visual search
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Add; // needed for add_task_annotations.go
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get; // needed for add_task_annotations.go
  }

  // Delete multiple tasks in one request.
  rpc DeleteTasks (DeleteTasksRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/tasks"
      body: "*"
      additional_bindings122 {
        delete: "/v2/tasks"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Tasks_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Tasks_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Tasks_Delete;
  }

  ////////////////////////////////////////
  // Label Order
  ////////////////////////////////////////

  // Add Label orders.
  rpc PostLabelOrders (PostLabelOrdersRequest) returns (MultiLabelOrderResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/label_orders"
      body: "*"
      additional_bindings123 {
        post: "/v2/label_orders"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_private_rpc) = false;
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = LabelOrders_Get;
    option (clarifai.auth.util.cl_depending_scopes) = LabelOrders_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Tasks_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Tasks_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Search;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get; // needed for converting workers internal ids to external ids
  }


  // Get a label order.
  rpc GetLabelOrder (GetLabelOrderRequest) returns (SingleLabelOrderResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/label_orders/{label_order_id}"
      additional_bindings124 {
        get: "/v2/label_orders/{label_order_id}"
      }
    };
    option (clarifai.auth.util.cl_private_rpc) = false;
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = LabelOrders_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Tasks_Get; // needed because task is embedded
  }

  // List label orders.
  rpc ListLabelOrders (ListLabelOrdersRequest) returns (MultiLabelOrderResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/label_orders"
      additional_bindings125 {
        get: "/v2/label_orders"
      }
    };
    option (clarifai.auth.util.cl_private_rpc) = false;
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = LabelOrders_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Tasks_Get; // needed because task is embedded
  }

  // Patch one or more label orders.
  rpc PatchLabelOrders (PatchLabelOrdersRequest) returns (MultiLabelOrderResponse) {
    option (google.api.http) = {
      patch: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/label_orders"
      body: "*"
      additional_bindings126 {
        patch: "/v2/label_orders"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_private_rpc) = false;
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = LabelOrders_Get;
    option (clarifai.auth.util.cl_depending_scopes) = LabelOrders_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Tasks_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Tasks_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Tasks_Delete;
  }

  // Delete multiple label orders in one request.
  // this do not change task status
  rpc DeleteLabelOrders (DeleteLabelOrdersRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/label_orders"
      body: "*"
      additional_bindings127 {
        delete: "/v2/label_orders"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_private_rpc) = false;
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = LabelOrders_Delete;
    option (clarifai.auth.util.cl_depending_scopes) = LabelOrders_Get;
    option (clarifai.auth.util.cl_depending_scopes) = LabelOrders_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Tasks_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Tasks_Get;
  }

  ////////////////////////////////////////
  // Collectors
  ////////////////////////////////////////

  // Add a list of Collectors to an app.
  // In the handler of this endpoint we also check for all the scopes of the  POST /inputs
  // endpoint.
  // Those current scopes are listed here as a hard requirement.
  // They are needed when adding the collectors just so we now that you have permission with
  // that key at least to do the writing to this app with POST /inputs.
  rpc PostCollectors (PostCollectorsRequest) returns (MultiCollectorResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/collectors"
      body: "*"
      additional_bindings128 {
        post: "/v2/collectors"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Collectors_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Concepts_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Inputs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Models_Get;
    option (clarifai.auth.util.cl_depending_scopes) = Predict;
    option (clarifai.auth.util.cl_depending_scopes) = Workflows_Get;
  }

  // Get a specific collector from an app.
  rpc GetCollector (GetCollectorRequest) returns (SingleCollectorResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/collectors/{collector_id}"
      additional_bindings129 {
        get: "/v2/collectors/{collector_id}"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Collectors_Get;
  }

  // List all the collectors.
  rpc ListCollectors (ListCollectorsRequest) returns (MultiCollectorResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/collectors"
      additional_bindings130 {
        get: "/v2/collectors"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Collectors_Get;
  }

  // Patch one or more collectors.
  rpc PatchCollectors (PatchCollectorsRequest) returns (MultiCollectorResponse) {
    option (google.api.http) = {
      patch: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/collectors"
      body: "*"
      additional_bindings131 {
        patch: "/v2/collectors"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Collectors_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Collectors_Get;
  }


  // Delete multiple collectors in one request.
  // This call is asynchronous. Use DeleteCollector if you want a synchronous version.
  rpc DeleteCollectors (DeleteCollectorsRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/collectors"
      body: "*"
      additional_bindings132 {
        delete: "/v2/collectors"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Collectors_Add;
    option (clarifai.auth.util.cl_depending_scopes) = Collectors_Delete;
    option (clarifai.auth.util.cl_depending_scopes) = Collectors_Get;
  }

  ////////////////////////////////////////////////////////////////////////////////
  // Stats Collection Endpoints.
  ////////////////////////////////////////////////////////////////////////////////

  rpc PostStatValues (PostStatValuesRequest) returns (MultiStatValueResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/stats/values"
      body: "*"
      additional_bindings133 {
        post: "/v2/stats/values"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
  }


  rpc PostStatValuesAggregate (PostStatValuesAggregateRequest) returns (MultiStatValueAggregateResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/stats/values/aggregate"
      body: "*"
      additional_bindings134 {
        post: "/v2/stats/values/aggregate"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
  }


  ////////////////////////////////////////////////////////////////////////////////
  // SDK Endpoints. Will be deprecated
  ////////////////////////////////////////////////////////////////////////////////
  // Add a new analytics entry into our database
  // note(lowjiansheng): not following convention for request formats as this proto definition is being used in many parts of Mobile SDK
  rpc PostAnalytics (PostAnalyticsRequest) returns (PostAnalyticsResponse) {
    option (google.api.http) = {
            post: "/v2/analytics"
            body: "*"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = All;
  }

  // Add a new sdk_billing entry into our database
  // note(lowjiansheng): not following convention for request formats as this proto definition is being used in many parts of Mobile SDK
  rpc PostSDKBilling (PostSDKBillingRequest) returns (PostSDKBillingResponse) {
    option (google.api.http) = {
        post: "/v2/sdkbilling"
        body: "*"
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = NoAuth;
  }

  // Find annotations duplicates based on an specified attribute of different annotations
  rpc PostFindDuplicateAnnotationsJobs(PostFindDuplicateAnnotationsJobsRequest) returns (MultiFindDuplicateAnnotationsJobResponse) {
    option (google.api.http) = {
      post: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/annotations/find_duplicates/jobs"
      body: "*"
      additional_bindings135 {
        post: "/v2/annotations/find_duplicates/jobs"
        body: "*"
      }
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = Annotations_Get;
    option (clarifai.auth.util.cl_depending_scopes) = FindDuplicateAnnotationsJobs_Add;
    option (clarifai.auth.util.cl_depending_scopes) = FindDuplicateAnnotationsJobs_Get;
  }

  // Get annotations find duplicates jobs results by id
  rpc GetFindDuplicateAnnotationsJobs (GetFindDuplicateAnnotationsJobsRequest) returns (MultiFindDuplicateAnnotationsJobResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/annotations/find_duplicates/jobs/{id}"
      additional_bindings136 {
        get: "/v2/annotations/find_duplicates/jobs/{id}"
      }
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = FindDuplicateAnnotationsJobs_Get;
  }


  // List all the annotations find duplicates jobs results
  rpc ListFindDuplicateAnnotationsJobs(ListFindDuplicateAnnotationsJobsRequest) returns (MultiFindDuplicateAnnotationsJobResponse) {
    option (google.api.http) = {
      get: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/annotations/find_duplicates/jobs"
      additional_bindings137 {
        get: "/v2/annotations/find_duplicates/jobs"
      }
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = FindDuplicateAnnotationsJobs_Get;
  }

  rpc DeleteFindDuplicateAnnotationsJobs (DeleteFindDuplicateAnnotationsJobsRequest) returns (clarifai.api.status.BaseResponse) {
    option (google.api.http) = {
      delete: "/v2/users/{user_app_id.user_id}/apps/{user_app_id.app_id}/annotations/find_duplicates/jobs"
      additional_bindings138 {
        delete: "/v2/annotations/find_duplicates/jobs"
      }
    };
    option (clarifai.auth.util.cl_private_rpc) = true;
    option (clarifai.auth.util.cl_auth_type) = KeyAuth;
    option (clarifai.auth.util.cl_depending_scopes) = FindDuplicateAnnotationsJobs_Add;
    option (clarifai.auth.util.cl_depending_scopes) = FindDuplicateAnnotationsJobs_Get;
    option (clarifai.auth.util.cl_depending_scopes) = FindDuplicateAnnotationsJobs_Delete;
  }
}




// Split the results into pages.
message Pagination {
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks. Defaults to 1.
  uint32 page = 1;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults to 128.
  uint32 per_page = 2;
}


////////////////////////////////////////////////////////////////////////////////
// Requests / Responses from /proto/clarifai/api/annotation.proto
////////////////////////////////////////////////////////////////////////////////
message GetAnnotationRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string annotation_id = 2;
  string input_id = 3;
}

message ListAnnotationsRequest {
  reserved 4;

  clarifai.api.UserAppIDSet user_app_id = 1;

  // List annotations for these IDs
  repeated string ids = 2;

  // List annotations for these Input IDs
  // Note that 'ids' are optional but if the are provided the number and order in
  // 'ids' and 'input_ids' should match
  // If you do not specify 'ids' all the annotations for 'input_ids' are returned
  // If a you do not specify both 'input_ids' and 'ids' all the annotations in the app are returned
  repeated string input_ids = 3;

  // Only return the annotations that has one of these user IDs, effectively operating as an
  // OR among them to filter down the results.
  // If model_version_ids are also provided these user_ids are OR'd with them as well since
  // annotations are either provided by users or model versions and we want the union of any
  // provided user or model version annotations in the results of ListAnnotations request.
  // If no user_ids are provided then annotations from all users are returned.
  repeated string user_ids = 9;

  // Only return the annotations that has one of these model version IDs, effectively operating as an
  // OR among them to filter down the results.
  // If user_ids are also provided these model_versions_ids are OR'd with them as well since
  // annotations are either provided by users or model versions and we want the union of any
  // provided user or model version annotations in the results of ListAnnotations request.
  // If no model_version_ids are provided then annotations from all model versions are returned.
  repeated string model_version_ids = 10;

  // Set status to filter by a list of statuses
  // If not statuses are provided then annotations with any status will be returned.
  repeated clarifai.api.status.Status statuses = 5;

  // Set this flag to list both trusted and not trusted annotations
  // by default it's listing only trusted annotations
  bool list_all_annotations = 6;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 7;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 8;
  // Flag to filter annotations by task_id
  string task_id = 11;
}

message PostAnnotationsRequest {

  clarifai.api.UserAppIDSet user_app_id = 1;

  repeated Annotation annotations = 2;
}

message PatchAnnotationsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  repeated Annotation annotations = 2;

  // The action to perform on the patched objects
  // For now actions 'merge', 'overwrite', and 'remove' are supported
  string action = 3;
}

message PatchAnnotationsStatusRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // Annotation Status code
  clarifai.api.status.StatusCode status_code = 2;
  repeated string user_ids = 3;
  string task_id = 4;
  // 'overwrite' is supported
  string action = 5;

}

message PatchAnnotationsStatusResponse {
  clarifai.api.status.Status status = 1;
  repeated string user_ids = 2;
  uint32 updated_count = 3;
}

message DeleteAnnotationRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  string input_id = 2;

  string annotation_id = 3;
}

// Request to delete several things by the list of ids.
message DeleteAnnotationsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  // Delete annotations with IDs
  repeated string ids = 2;

  // Delete annotations for these Input IDs
  // Note that 'ids' are optional but if the are provided the number and order in
  // 'ids' and 'input_ids' should match
  // If you do not specifiy 'ids' all the annotations for 'input_ids' are deleted
  // However you need to specify at least one value for 'input_ids'
  // i.e. this API does not support deleting all annotations
  repeated string input_ids = 3;
}

message SingleAnnotationResponse {
  clarifai.api.status.Status status = 1;
  Annotation annotation = 2;
}

message MultiAnnotationResponse {
  clarifai.api.status.Status status = 1;

  repeated Annotation annotations = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// Requests / Responses from /proto/clarifai/api/app.proto
////////////////////////////////////////////////////////////////////////////////
message GetAppRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
}

message ListAppsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 2;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 3;
}

message PostAppsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated App apps = 2;
}

message DeleteAppRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
}

message PatchAppsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated App apps = 2;

  // The action to perform on the patched App objects except App.Metadata
  // For now only action 'overwrite' is supported
  string action = 3;

  // The action to perform on the patched App.Metadata
  clarifai.api.PatchAction metadata_action = 4;

  // If set, the app will be automatically reindexed upon change of its base workflow.
  bool reindex = 5;
}

// Search over the available applications.
message PostAppsSearchesRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // The body of the request.
  AppQuery app_query = 2;
  // Pagination parameters here since there are no url args in this
  // POST request.
  Pagination pagination = 3;
}

message SingleAppResponse {
  clarifai.api.status.Status status = 1;
  App app = 2;
}

message MultiAppResponse {
  clarifai.api.status.Status status = 1;
  repeated App apps = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////
// Requests / Responses from /proto/clarifai/api/app_sharing.proto
////////////////////////////////////////////////////////////////////////////////
message ListCollaboratorsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // Set this flag to list both deleted and not deleted collaborators
  // by default it's listing only not deleted collaborators
  bool list_all_collaborators = 2;
}

message PostCollaboratorsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated Collaborator collaborators = 2;
}

message PatchCollaboratorsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated Collaborator collaborators = 2;

  // The action to perform on the patched objects
  // For now only action 'overwrite' is supported
  string action = 3;
}

message DeleteCollaboratorsRequest{
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated string collaborator_ids = 2;
  repeated string user_emails = 3;
}

message MultiCollaboratorsResponse {
  clarifai.api.status.Status status = 1;
  repeated Collaborator collaborators = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

message ListCollaborationsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 2;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 3;
}

message MultiCollaborationsResponse {
  clarifai.api.status.Status status = 1;
  repeated Collaboration collaborations = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}
////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////
// Requests / Responses from /proto/clarifai/api/audio.proto
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////
// Requests / Responses from /proto/clarifai/api/auth.proto
////////////////////////////////////////////////////////////////////////////////

message PostVerifyEmailRequest {
  string key = 1;
}

message SingleVerifyEmailResponse {
  clarifai.api.status.Status status = 1;
}

message ListAuthMethodsRequest {
  // (optional URL parameter) Recovery path that the user will be redirected back to after login
  string recovery_path = 1;
  clarifai.api.UserAppIDSet user_app_id = 2;
}

message ListAuthMethodsResponse {
  // Status of this request.
  clarifai.api.status.Status status = 1;
  // List of authentication methods.
  repeated AuthMethod auth_methods = 2;
}

////////////////
// 2FA (Two factor authentication)
message List2FAMethodsRequest {
  // Contains the user_id. Has to match the caller.
  clarifai.api.UserAppIDSet user_app_id = 1;
}

message List2FAMethodsResponse {
  // Status of this request.
  clarifai.api.status.Status status = 1;
  // List of authentication methods.
  repeated TwoFactorAuthMethod two_factor_auth_methods = 2;
}

message PostAuth2FATotpRegisterEnableRequest {
  // Contains the user_id. Has to match the caller.
  clarifai.api.UserAppIDSet user_app_id = 1;
}

message PostAuth2FATotpRegisterEnableResponse {
  // Status of this request.
  clarifai.api.status.Status status = 1;
  string secret = 2;
  string qr_code = 3;
  string state = 4;
}

message PostAuth2FATotpDisableRequest {
  string passcode = 1;
  // Contains the user_id. Has to match the caller.
  clarifai.api.UserAppIDSet user_app_id = 2;
}

message PostAuth2FATotpDisableResponse {
  // Status of this request.
  clarifai.api.status.Status status = 1;
}

message PostAuth2FATotpRegisterVerifyRequest {
  string passcode = 1;
  string state = 2;
  // Contains the user_id. Has to match the caller.
  clarifai.api.UserAppIDSet user_app_id = 3;
}

message PostAuth2FATotpRegisterVerifyResponse {
  // Status of this request.
  clarifai.api.status.Status status = 1;
  string recovery_key = 2;
}

message PostAuth2FATotpLoginRequest {
  string passcode = 1;
  string state = 2;
  string user_id = 3;
  bool long_lived = 4;
}

message PostAuth2FATotpRecoverRequest {
  string state = 1;
  string recovery_code = 2;
  string user_id = 3;
}

message PostAuth2FATotpRecoverResponse {
  // Status of this request.
  clarifai.api.status.Status status = 1;
}

message GetAuth2FATotpRecoverConfirmRequest {
  // (required URL parameter) Confirmation secret for validation
  string state = 1;
}

message GetAuth2FATotpRecoverConfirmResponse {
  // Status of this request.
  clarifai.api.status.Status status = 1;
}

////////////////
// Reset Password
message RequestResetPasswordRequest {
  //To find associated account.
  string email = 1;
}

message CompleteResetPasswordRequest {
  //key to retrieve user
  string key = 1;
  //new password to set.
  string new_password = 2;
}

/////////////
// Login and Signup
message PostLoginRequest {
  string email = 1;
  string password = 2;
  bool long_lived = 3;
}

message PostSignupRequest {
  string email = 1;
  string password = 2;
  string first_name = 3;
  string last_name = 4;
  string company_name = 5;
  string captcha_response_token = 6;
  // This field is only for registrations that come from the AWS marketplace
  string aws_registration_token = 7;
  bool gdpr_consent = 8;
  bool tos_consent = 9;
  bool marketing_consent = 10;
  string job_title = 11;
  string job_role = 12;
}

message SingleLoginResponse {
  clarifai.api.status.Status status = 1;
  string email = 2;
  string first_name = 3;
  string last_name = 4;
  string company_name = 5;
  string date_joined = 6;
  repeated EmailAddress email_addresses = 8;
  string session_token = 9;
  string token_expires = 10;
  // This is the user.id:
  string v2_user_id = 11;
  string date_gdpr_consent = 12;
  string date_tos_consent = 13;
  string date_marketing_consent = 14;
  // For checking if password expired
  string password_expired_at = 15;
  bool is_new_user = 16;
  bool two_factor_auth_enabled = 17;
  string state = 18;
}

message PostLogoutRequest {
  // Contains the user_id to logout. Has to match the caller.
  clarifai.api.UserAppIDSet user_app_id = 1;
}

message SingleLogoutResponse {
  clarifai.api.status.Status status = 1;
}
//////////////
// Billing Usage
message GetBillingUsageRequest {
  // Contains the user_id. Has to match the caller.
  clarifai.api.UserAppIDSet user_app_id = 1;
}

message GetBillingUsageResponse {
  clarifai.api.status.Status status = 1;
  repeated InvoiceItem invoice_items = 2;
  BillingCycle billing_cycle = 3;
}

////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////
// Requests / Responses from /proto/clarifai/api/cluster.proto
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////
// Requests / Responses from /proto/clarifai/api/code.proto
////////////////////////////////////////////////////////////////////////////////
message GetStatusCodeRequest {
  string status_code_id = 1;
}

message ListStatusCodesRequest {
}

message SingleStatusCodeResponse {
  // Status of this request.
  clarifai.api.status.Status status = 1;
}

message MultiStatusCodeResponse {
  clarifai.api.status.Status status = 1;
  repeated clarifai.api.status.Status statuses = 2;
}

////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////
// Requests / Responses from /proto/clarifai/api/color.proto
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////
// Requests / Responses from /proto/clarifai/api/common.proto
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////
// Requests / Responses from /proto/clarifai/api/concept.proto
////////////////////////////////////////////////////////////////////////////////
message GetConceptRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // The concept's id.
  string concept_id = 2;
}

message ListConceptsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 2;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 3;
}

message PostConceptsSearchesRequest {
  // Ids present in the url of the request.
  clarifai.api.UserAppIDSet user_app_id = 1;
  // The body of the request.
  ConceptQuery concept_query = 2;
  // Pagination parameters here since there are no url args in this
  // POST request.
  Pagination pagination = 3;
}

message PostConceptsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // The concepts to add.
  repeated Concept concepts = 2;
}

message PatchConceptsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // The concepts to patch.
  repeated Concept concepts = 2;

  // The action to perform on the patched objects
  // For now ony action 'overwrite' is supported
  string action = 3;
}

message GetConceptCountsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 2;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 3;
}

message SingleConceptResponse {
  // The response status.
  clarifai.api.status.Status status = 1;
  // The returned concept.
  Concept concept = 2;
}

message MultiConceptResponse {
  // The response status.
  clarifai.api.status.Status status = 1;
  // The returned concepts.
  repeated Concept concepts = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

message MultiConceptCountResponse {
  // The response status.
  clarifai.api.status.Status status = 1;
  // The returned concept counts.
  repeated ConceptCount concept_counts = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////
// Requests / Responses from /proto/clarifai/api/concept_graph.proto
////////////////////////////////////////////////////////////////////////////////
//////////////////////
// Responses
//////////////////////
// Requests
//////////////////////
// GET all relations such that the concept_id refers to the subject of the relation
message ListConceptRelationsRequest {
  // The user_id and app_id information.
  clarifai.api.UserAppIDSet user_app_id = 1;
  // The subject concept id in your app to get all the relationships for.
  // Leave as an empty string (GET /concepts/relations) to list ALL the relations in the app.
  //
  // When listing all the relations it will only return one direction of the relationship
  // with the predicate acting on the subject and not the inverse like is done when providing a
  // concept_id so that we can return a reliable page size always.
  //
  // When providing a concept_id, if a hyponym is present in the DB such as:
  // 'honey' (subject), 'hyponym' (predict for "is a kind of"), 'food' (object)
  // then you can list the concept relations for 'honey' and get hyponym predicate with 'food'
  // object.
  // But you can also list the concept relations for 'food' and it will return the same hyponym
  // relationship with 'honey' as subject and 'food' as predicate.
  // Synonyms by nature are symmetrical relationships so either side can be the concept_id (subject)
  // when listing the relations.
  string concept_id = 2;
  // This is part of the url so we can extend to multiple link types in the future.
  // Valid predicates are:
  // 'hypernyms'
  // 'hyponyms'
  string predicate = 3;
  // If knowledge_graph_id is provided then just list relations from that knowledge graph.
  // If not provided then list relations from all knowledge graphs including the global one for this
  // app one (ie. knowledge_graph "") and any specific ones in the app.
  string knowledge_graph_id = 4;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 5;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 6;
}

// POST new concept relations
message PostConceptRelationsRequest {
  // The user_id and app_id information.
  clarifai.api.UserAppIDSet user_app_id = 1;
  // The subject concept id you're going to add relations for.
  string concept_id = 2;
  // The relationships you're going to add.
  repeated ConceptRelation concept_relations = 3;
}

// DELETE concept relations
message DeleteConceptRelationsRequest {
  // The user_id and app_id information.
  clarifai.api.UserAppIDSet user_app_id = 1;
  // The concept to delete relationship for.
  string concept_id = 2;
  // The concept relationship ids to delete.
  repeated string ids = 3;
}

// GET all knowledge graphs
message ListKnowledgeGraphsRequest {
  // The user_id and app_id information.
  clarifai.api.UserAppIDSet user_app_id = 1;
}

// POST new knowledge graphs
message PostKnowledgeGraphsRequest {
  // The user_id and app_id information.
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated KnowledgeGraph knowledge_graphs = 2;
}

// GET all concept mappings for the app
message ListConceptMappingsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 2;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 3;
}

// POST concept mappings
message PostConceptMappingsRequest {
  // The user_id and app_id information.
  clarifai.api.UserAppIDSet user_app_id = 1;
  // The concept mappings that are being added
  repeated ConceptMapping concept_mappings = 2;
  // The knowledge graph that is being used for these concept mappings
  KnowledgeGraph knowledge_graph = 3;
}

// Start concept mapping jobs
message PostConceptMappingJobsRequest {
  // The user_id and app_id information.
  clarifai.api.UserAppIDSet user_app_id = 1;
  // The concept mapping jobs that are being started
  repeated ConceptMappingJob concept_mapping_jobs = 2;
}

//////////////////////
// Responses
//////////////////////
message SingleConceptRelationResponse {
  // The response status.
  clarifai.api.status.Status status = 1;
  // The returned concept relation.
  ConceptRelation concept_relation = 2;
}

message MultiConceptRelationResponse {
  // The response status.
  clarifai.api.status.Status status = 1;
  // The returned concept relations.
  repeated ConceptRelation concept_relations = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

message SingleKnowledgeGraphResponse {
  // The response status.
  clarifai.api.status.Status status = 1;
  // The returned knowledge graph.
  KnowledgeGraph knowledge_graph = 2;
}

message MultiKnowledgeGraphResponse {
  // The response status.
  clarifai.api.status.Status status = 1;
  // The returned knowledge graphs.
  repeated KnowledgeGraph knowledge_graphs = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

message SingleConceptMappingResponse {
  // The response status.
  clarifai.api.status.Status status = 1;
  // The returned mapped concept.
  ConceptMapping concept_mapping = 2;
}

message MultiConceptMappingResponse {
  // The response status.
  clarifai.api.status.Status status = 1;
  // The returned mapped concepts.
  repeated ConceptMapping concept_mappings = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

message SingleConceptMappingJobResponse {
  // The response status.
  clarifai.api.status.Status status = 1;
  // The id of the concept mapping job underway.
  string id = 2;
}

message MultiConceptMappingJobResponse {
  // The response status.
  clarifai.api.status.Status status = 1;
  // The ids of the concept mapping jobs underway.
  repeated string ids = 2;
}

////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////
// Requests / Responses from /proto/clarifai/api/concept_language.proto
////////////////////////////////////////////////////////////////////////////////
// GET single concept language for the given concept.
message GetConceptLanguageRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string concept_id = 2;
  // This is the language identifier.
  string language = 3;
}

// List multiple concept languages for the given concept.
message ListConceptLanguagesRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string concept_id = 2;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 3;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 4;
}

// PATCH multiple concept languages for the given concept.
message PatchConceptLanguagesRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string concept_id = 2;
  repeated ConceptLanguage concept_languages = 3;
  // The action to perform with the objects in the PATCH.
  string action = 4;
}

// // DELETE multiple concept languages for the given concept.
// message DeleteConceptLanguageRequest {
//   clarifai.api.UserAppIDSet user_app_id = 1;
//   string concept_id = 2;
//   // The language code to delete.
//   string language = 3;
// }

// // DELETE multiple concept languages for the given concept.
// message DeleteConceptLanguagesRequest {
//   clarifai.api.UserAppIDSet user_app_id = 1;
//   string concept_id = 2;
//   // The language code(s) to delete.
//   string ids = 3;
//   bool delete_all = 4;
// }

// POST multiple concept languages for the given concept.
message PostConceptLanguagesRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string concept_id = 2;
  repeated ConceptLanguage concept_languages = 3;
}

message SingleConceptLanguageResponse {
  clarifai.api.status.Status status = 1;
  ConceptLanguage concept_language = 2;
}

message MultiConceptLanguageResponse {
  clarifai.api.status.Status status = 1;
  repeated ConceptLanguage concept_languages = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////
// Requests / Responses from /proto/clarifai/api/concept_reference.proto
////////////////////////////////////////////////////////////////////////////////
message ListConceptReferencesRequest {
  // The user id and app id set in the url.
  clarifai.api.UserAppIDSet user_app_id = 1;
  // The concept id you want to list translations for.
  string concept_id = 2;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 3;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 4;
}

message SingleConceptReferenceResponse {
  clarifai.api.status.Status status = 1;
  ConceptReference concept_reference = 2;
}

message MultiConceptReferenceResponse {
  clarifai.api.status.Status status = 1;
  repeated ConceptReference concept_references = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////
// Requests / Responses from /proto/clarifai/api/data.proto
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////
// Requests / Responses from /proto/clarifai/api/embedding.proto
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////
// Requests / Responses from /proto/clarifai/api/face.proto
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////
// Requests / Responses from /proto/clarifai/api/focus.proto
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////
// Requests / Responses from /proto/clarifai/api/geo.proto
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////
// Requests / Responses from /proto/clarifai/api/healthz.proto
////////////////////////////////////////////////////////////////////////////////
message GetHealthzRequest {
}

message GetHealthzResponse {
  clarifai.api.status.Status status = 1;
  string time = 2;
}

////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////
// Requests / Responses from /proto/clarifai/api/image.proto
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////
// Requests / Responses from /proto/clarifai/api/input.proto
////////////////////////////////////////////////////////////////////////////////
message GetInputRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string input_id = 2;
}

message GetInputSamplesRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string task_id = 2;
  // URL param. If zero ids provided, returns for all task labelers
  repeated string user_ids = 3;
}

message ListInputsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 2;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 3;

  // Set status to filter by status
  clarifai.api.status.Status status = 5;

  repeated string ids = 4;
}

message StreamInputsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 20.
  uint32 per_page = 2;
  string last_id = 3;


  bool descending = 4;
}

message PostInputsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  repeated Input inputs = 2;
}

message PostInputsFileRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  // url to the file.
  string url = 2;

  // type of the file. Currently only support `csv`
  string filetype = 3;
}

message PostInputsNiFiRequest {
  option (clarifai.auth.util.cl_private_message) = true;

  clarifai.api.UserAppIDSet user_app_id = 1;
  google.protobuf.ListValue urls = 2;
  // For arbitrary JSON input, use a struct field:
  // https://github.com/google/protobuf/blob/master/src/google/protobuf/struct.proto
  // The metadata contains info about the provenance of the files. The provenance info allows user
  // locate the original source files after ingestion. Metadata should be searchable and displayed
  // in output.
    google.protobuf.Struct metadata = 3;
  // The params contains key/value pairs sent by NiFi in case we need certain parameters to be set
  // to successfully ingest inputs.
  google.protobuf.Struct params = 4;
}

message PostInputsDocumentRequest {
  option (clarifai.auth.util.cl_private_message) = true;

  clarifai.api.UserAppIDSet user_app_id = 1;
  // Body of the request
  PostInputsDocumentRequestBody body = 2;
  // Query parameter: send the status of the inputs to 3rd party using this url.
  // If empty, the status will not be sent.
  string statusCallbackUrl = 3;
  // Query parameter: send the prediction of the inputs (i.e. entities) to 3rd party using this url.
  // If empty, the entities will not be sent.
  string entityCallbackUrl = 4;
}

message PostInputsDocumentRequestBody {
  option (clarifai.auth.util.cl_private_message) = true;

  // Track batch status using this batch identifier.
  // 3rd party calls sent to statusCallbackUrl and entityCallbackUrl will use this batch id.
  string batchId_t = 1;
  // List of documents which contain inputs.
  google.protobuf.ListValue document = 2;
  // Not used, but needs to be supported.
  google.protobuf.Struct complete = 3;
  // Not used, but needs to be supported.
  google.protobuf.Struct metadata = 4;
}

message PatchInputsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  repeated Input inputs = 2;

  // The action to perform on the patched objects
  // For now actions 'merge', 'overwrite', and 'remove' are supported
  string action = 3;
}

message DeleteInputRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string input_id = 2;
}

// Request to delete several things by the list of ids.
message DeleteInputsRequest {
  reserved 3;

  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated string ids = 2;
}

message SingleInputResponse {
  clarifai.api.status.Status status = 1;
  Input input = 2;
}

message MultiInputResponse {

  clarifai.api.status.Status status = 1;
  repeated Input inputs = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

message MultiInputAnnotationResponse {

  clarifai.api.status.Status status = 1;
  repeated Hit hits = 3 [(clarifai.api.utils.cl_show_if_empty) = true];
}

message SingleInputCountResponse {
  clarifai.api.status.Status status = 1;

  // NOTE: inconsistency: not named after the object name.
  InputCount counts = 2;
}

message GetInputCountRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
}

////////////////////////////////////////////////////
// Model prediction related stuff needs inputs and produces outputs.
////////////////////////////////////////////////////
// Model prediction.
message PostModelOutputsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string model_id = 2;
  string version_id = 3;
  repeated Input inputs = 4;
  // This allows you to specify config options for the model such as
  // the language which appear's in the model's output_info.
  Model model = 5;
}

// Listing the inputs that went into training this model.
message ListModelInputsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string model_id = 2;
  string version_id = 3;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 4;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 5;
}

////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////
// Requests / Responses from /proto/clarifai/api/key.proto
////////////////////////////////////////////////////////////////////////////////
message GetKeyRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string key_id = 2;
}

message ListKeysRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 2;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 3;
}

message ListAppKeysRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 2;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 3;
}

message PostKeysRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated Key keys = 2;
}

message DeleteKeyRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string key_id = 2;
}

message PatchKeysRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated Key keys = 2;

  // The action to perform on the patched objects
  // For now only action 'overwrite' is supported
  string action = 3;
}

message SingleKeyResponse {
  clarifai.api.status.Status status = 1;
  Key key = 2;
}

message MultiKeyResponse {
  clarifai.api.status.Status status = 1;
  repeated Key keys = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////
// Requests / Responses from /proto/clarifai/api/license.proto
////////////////////////////////////////////////////////////////////////////////
message FetchLicenseRequest {
  string license_id = 1;
  string public_key = 2; // public key generated in client side, per-activation scope (only created when client first fetches license file, but it is decided by client)
  bytes signature = 3;
}

message FetchLicenseResponse {
  clarifai.api.status.Status status = 1;
  bytes encrypted_bytes = 2;
  google.protobuf.Timestamp activated_at = 3; // Date and time the deployment was activated
  string public_key = 4;
  bytes signature = 5;
}

message ValidateLicenseRequest {
  string license_id = 1;
  string request_id = 2; // used to prevent users providing faked but valid response
  //for example, returned by previous successful validation
  google.protobuf.Timestamp activated_at = 3;
  string public_key = 4; // public key generated in client side
  bytes signature = 5;
}

message ValidateLicenseResponse {
  clarifai.api.status.Status status = 1;
  string request_id = 2; // mapping to the request_id in request
  repeated LicenseLimit limits = 3;
  bytes signature = 4;
}

message ListLicensesRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
}

message GetLicenseRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string license_id = 2;
}

message SingleLicenseResponse {
  clarifai.api.status.Status status = 1;
  clarifai.api.License license = 2;
}

message MultipleLicensesResponse {
  clarifai.api.status.Status status = 1;
  repeated clarifai.api.License licenses = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////
// Requests / Responses from /proto/clarifai/api/model.proto
////////////////////////////////////////////////////////////////////////////////
message GetModelRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string model_id = 2;
  // This is included so that we can re-use this request for multiple
  // rpcs with and without the version_id.
  string version_id = 3;
  string language = 4;
  bool trained_before = 5;
}

message ListModelsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 2;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 3;
  repeated string ids = 4;
}

message PostModelsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  // NOTE: inconsistent since "model" is not plural, please use "models" below.
  // Previously you could only create one model at a time.
  // We still support this but you should pass it as models=[model] so
  // that this endpoint is consistent with the rest of our API.
  Model model = 2 [deprecated = true];
  // This allows you to create one or more model by posting it to the API.
  repeated Model models = 3;
}

message PatchModelsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated Model models = 2;

  // The action to perform on the patched objects
  // For now actions 'merge', 'overwrite', and 'remove' are supported
  string action = 3;
}

message DeleteModelRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string model_id = 2;
}

// Request to delete several things by the list of ids.
message DeleteModelsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated string ids = 2;
  bool delete_all = 3;
}

// Search over the available models.
message PostModelsSearchesRequest {
  // Ids present in the url of the request.
  clarifai.api.UserAppIDSet user_app_id = 1;
  // The body of the request.
  ModelQuery model_query = 2;
  // Pagination parameters here since there are no url args in this
  // POST request.
  Pagination pagination = 3;
}

message SingleModelResponse {
  clarifai.api.status.Status status = 1;
  Model model = 2;
}

message MultiModelResponse {
  clarifai.api.status.Status status = 1;
  repeated Model models = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////
// Requests / Responses from /proto/clarifai/api/model_version.proto
////////////////////////////////////////////////////////////////////////////////
message PatchModelVersionsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string model_id = 2;
  repeated ModelVersion model_versions = 3;
  // The action to perform on the patched objects
  // For now actions 'merge', 'overwrite', and 'remove' are supported
  string action = 4;
}

// NOTE: this is same as GetModelRequest but backend doesn't support sharing same
// request for different endpoints currently.
message GetModelVersionRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string model_id = 2;
  string version_id = 3;
}

message ListModelVersionsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string model_id = 2;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 3;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 4;
  // To list only the model versions that have these concept ids present in them.
  repeated string concept_ids = 5;
}

message DeleteModelVersionRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string model_id = 3;
  string version_id = 4;
}

message SingleModelVersionResponse {
  clarifai.api.status.Status status = 1;
  ModelVersion model_version = 2;
}

message MultiModelVersionResponse {
  clarifai.api.status.Status status = 1;
  repeated ModelVersion model_versions = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

// Create (train) a new model version.
message PostModelVersionsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string model_id = 2;

  // This lets you post an existing model version rather than training a new one.
  // For internal Clarifai use only to start.
  repeated ModelVersion model_versions = 3;

  // Use this to filter inputs that are used in training
  clarifai.api.Search search = 4 [deprecated = true];
  //train_search is used to specify what data to train on.
  clarifai.api.Search train_search = 5;
  //test_search is used to specify what data to test on.
  clarifai.api.Search test_search = 6;
  // whether to evaluate the transfer trained model after training
  bool evaluate_after_training = 7;
  // Description about this training run
  string description = 8;
}


// Evaluate this model version.
message PostModelVersionMetricsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string model_id = 2;
  string version_id = 3;
  uint32 max_examples = 4;

  // Use this to filter inputs that are used in evaluation
  clarifai.api.Search test_search = 5;
}

// Get the already computed evaluation metrics for this model
// version.
message GetModelVersionMetricsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string model_id = 2;
  string version_id = 3;

  // Any of the fields you wish to return from multiclass_metrics
  FieldsValue fields = 4;
}


// TODO: should we just move to this and get rid of above.
// // Request to delete several things by the list of ids.
// message DeleteModelVersionsRequest {
//   clarifai.api.UserAppIDSet user_app_id = 1;
//   repeated string ids = 2;
//   bool delete_all = 3;
// }

////////////////////////////////////////////////////////////////////////////////

message GetModelTypeRequest {
  // use and app combo. Not really used for this endpoint at this time so may go away in future.
  clarifai.api.UserAppIDSet user_app_id = 1;
  // The specific ModelType.Id you want to retrieve.
  string model_type_id = 2;
}

message ListModelTypesRequest {
  // use and app combo. Not really used for this endpoint at this time so may go away in future.
  clarifai.api.UserAppIDSet user_app_id = 1;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 2;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 3;
}

message SingleModelTypeResponse {
  // Status of the response.
  clarifai.api.status.Status status = 1;
  // The retrieved ModelType object. .
  ModelType model_type = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

message MultiModelTypeResponse {
  // Status of the response.
  clarifai.api.status.Status status = 1;
  // List of ModelType objects.
  repeated ModelType model_types = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}


////////////////////////////////////////////////////////////////////////////////
// Requests / Responses from /proto/clarifai/api/output.proto
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////
// Outputs related requests
////////////////////////////////////////////////////
message MultiOutputResponse {
  clarifai.api.status.Status status = 1;
  repeated Output outputs = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////
// Requests / Responses from /proto/clarifai/api/scope.proto
////////////////////////////////////////////////////////////////////////////////
message ListScopesRequest {
  // If "personal_access_token" include scopes and endpoints available to personal access tokens.
  // If "api_key" include scopes and endpoints available to app-specific keys. (default)
  string key_type = 1;

  // For all user specific information we include user_app_id to get the user_id in a consistent way
  clarifai.api.UserAppIDSet user_app_id = 2;
}

message MyScopesRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
}

message MultiScopeDepsResponse {
  // The status of the request.
  clarifai.api.status.Status status = 1;
  // scopes is a list of low-level scopes and their dependencies.
  repeated ScopeDeps scope_deps = 2;
  // endpoint_scopes is a listof all the publicly available endponts which can be
  // used as scopes as well. A call to each of those endpoint depends on a subset
  // of the above "scopes"
  repeated EndpointDeps endpoint_deps = 3;
}

message MultiScopeResponse {
  // The status of the request.
  clarifai.api.status.Status status = 1;
  // This is a list of the scopes that your key has.
  repeated string scopes = 2;
  // The app that the key has access to.
  App app = 3;
  // This is a list of endpoint permissions that your key has.
  repeated string endpoints = 4;
}

////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////
// Requests / Responses from /proto/clarifai/api/search.proto
////////////////////////////////////////////////////////////////////////////////
message GetSearchRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string id = 2;
}

message ListSearchesRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 2;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 3;
}

message PostSearchesRequest {
  // The user_id and app_id to query from.
  clarifai.api.UserAppIDSet user_app_id = 1;

  // The query; this specifies how the data to be searched
  // this will be replaced by "Searches"
  Query query = 2 [deprecated=true];

  // The searched to be executed or saved
  // Eventually the request level fields will be deprecated in favor of this object
  repeated Search searches = 3;

  // Pagination information to paginate through search result Hits.
  Pagination pagination = 4;
}

// PostSearchesByIDRequest performs returns results of a saved search given its ID
message PostSearchesByIDRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  // ID for saves search to be executed
  string id = 2;

  // Pagination information to paginate through search result Hits.
  Pagination pagination = 3;
}

message DeleteSearchRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string id = 2;
}

message PostAttributeSearchRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  Pagination pagination = 3;
  // Perform a brute force search visual search
  bool brute_force = 4;
  AttributeQuery attribute_query = 5;

  // Minimum value of confidence threshold score in result.
  // Defaults to 0.0 which means we won't do any thresholding as all probabilities will
  // likely be > 0.0.
  float min_value = 6;
}

// Execute a new annotation search and optionally save it
// annotation search over annotations using rank and filter proto
message PostAnnotationsSearchesRequest {
  // The user_id and app_id to query from.
  clarifai.api.UserAppIDSet user_app_id = 1;

  // The searched to be executed or saved
  repeated Search searches = 2;

  // Pagination information to paginate through search result Hits.
  Pagination pagination = 3;
}

message DeleteAnnotationSearchMetricsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string id = 2;
}

// Execute a new input search and optionally save it
message PostInputsSearchesRequest {
  // The user_id and app_id to query from.
  clarifai.api.UserAppIDSet user_app_id = 1;

  // The searched to be executed or saved
  repeated Search searches = 2;

  // Pagination information to paginate through search result Hits.
  Pagination pagination = 3;
}

// SingleSearchResponse returns saved search in response to GetSearchRequest
message SingleSearchResponse {
  // Status of whether the search was successful.
  clarifai.api.status.Status status = 1;
  Search search = 5;
}

message MultiSearchResponse {
  // Status of whether the search was successful.
  clarifai.api.status.Status status = 1;

  // A unique id which uniquely identifies a search
  string id = 2;

  // The list of search result Hits.
  repeated Hit hits = 3 [(clarifai.api.utils.cl_show_if_empty) = true];

  // The original query provided in the request.
  Query query = 4;

  // The original Searches provided in the request.
  repeated Search searches = 5;
}

message PostAnnotationSearchMetricsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  // A unique customer facing id to identify this eval request
  string id = 2;

  // The ground truth we are evaluating against
  clarifai.api.Search ground_truth = 3;

  // The set we are evaluating
  clarifai.api.Search search_to_eval = 4;

  // List of concepts to evaluate are expected to be in data.concepts
  // If nil, then all app concepts are used
  Data data = 5;

  // The type of evaluation to use
  EvaluationType evaluation_type = 6;
}

message GetAnnotationSearchMetricsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  // Unique custom facing id that identifies the eval to get
  string id = 2;
}

message ListAnnotationSearchMetricsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
}

message MultiAnnotationSearchMetricsResponse {
  // Status of the request
  clarifai.api.status.Status status = 1;
  repeated AnnotationSearchMetrics annotation_search_metrics = 2;
}

// ListClustersRequest returns a page of clusters sorted but their count in the app along with some
// statistics on usage of each cluster.
// Note each annotation is assigned to a cluster by a cluster model.
// It also retruns the most recent annotation for each cluster a representative for that cluster.
message ListClustersRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  // restrict listing to these cluster ids
  repeated string ids = 2;

  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 3;

  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 4;

  // number of annotations per cluster returned
  uint32 annotations_per_cluster = 5;
}

// ListAnnotationsForClusterRequest returns a page of annotations sorted by created_at timestamp for a cluster
message ListAnnotationsForClusterRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  // Cluster ID to get annotations for
  string cluster_id = 2;

  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 3;

  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 4;
}

message PostClustersSearchesRequest {
  // The user_id and app_id to query from.
  clarifai.api.UserAppIDSet user_app_id = 1;

  repeated Search searches = 2;

  // Pagination information to paginate through search result Hits.
  Pagination pagination = 3;
}

message MultiClusterResponse {
  clarifai.api.status.Status status = 1;

  // Cluster statistics and represetatives
  repeated Cluster clusters = 2 [(clarifai.api.utils.cl_show_if_empty) = true];

  // The original Search provided in the request (if any).
  repeated Search searches = 3;
}

////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////
// Requests / Responses from /proto/clarifai/api/subscription.proto
////////////////////////////////////////////////////////////////////////////////
// Gets a the current subscription based on your session token.
message GetSubscriptionRequest {
  // Contains the user_id. Has to match the caller.
  clarifai.api.UserAppIDSet user_app_id = 1;
}

// FIXME: why is this used to change subscriptions as a POST and not PATCH?
message PostSubscriptionRequest {
  string signup_code = 1;
  Plan plan = 2;
  // Contains the user_id. Has to match the caller.
  clarifai.api.UserAppIDSet user_app_id = 3;
}

message SingleSubscriptionResponse {
  clarifai.api.status.Status status = 1;
  Plan plan = 2;
  string signup_code = 3;
}

message ListCreditCardsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
}

message MultipleCreditCardResponse {
  clarifai.api.status.Status status = 1;
  repeated CreditCard cards = 2;
}

message PostCreditCardRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string source = 2;
  CreditCard card = 3;
}

message SingleCreditCardResponse {
  clarifai.api.status.Status status = 1;
  CreditCard card = 2;
}

message DeleteCreditCardRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  CreditCard card = 2;
}

message PatchCreditCardsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated CreditCard cards = 2;
  clarifai.api.PatchAction action = 3;
}

message GetShippingAddressRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
}

message PutShippingAddressRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  ShippingAddress shipping_address = 2;
  clarifai.api.PatchAction action = 3;
}

message SingleShippingAddressResponse {
  clarifai.api.status.Status status = 1;
  ShippingAddress shipping_address = 2;
}

message ListPlansRequest{
  clarifai.api.UserAppIDSet user_app_id = 1;
}

message MultiPlanResponse {
  clarifai.api.status.Status status = 1;
  repeated Plan plans = 2;
}



////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////
// Requests / Responses from /proto/clarifai/api/text.proto
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////
// Requests / Responses from /proto/clarifai/api/usage.proto
////////////////////////////////////////////////////////////////////////////////
message PostHistoricalUsageRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // NOTE: add plotting parameters here as we expand the usage-dashboard functionality
}

message PostHistoricalUsageResponse {
  clarifai.api.status.Status status = 1;

  // in the future, we will also have an optional field for billing cycle:
  google.protobuf.Duration interval = 2;
  repeated DimensionList usage = 3 [(clarifai.api.utils.cl_show_if_empty) = true];
}

message GetRealtimeUsageRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
}

message GetRealtimeUsageResponse {
  clarifai.api.status.Status status = 1;
  repeated RealtimeCount realtime_usage = 4;
}

message ListUsageIntervalsRequest {
}

message ListUsageIntervalsResponse {
  clarifai.api.status.Status status = 1;
  repeated UsageInterval usage_intervals = 2;
}

message ListUserBillingCyclesRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 2;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 3;
}

message ListUserBillingCyclesResponse {
  clarifai.api.status.Status status = 1;
  repeated BillingCycle billing_cycles = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

message PostUsageRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated EventsCollection events_collections = 2;
  string public_key = 3; // public key generated in client side
  bytes signature = 4;
}

message PostUsageResponse {
  clarifai.api.status.Status status = 1;
}

////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////
// Requests / Responses from /proto/clarifai/api/usage_interval_type.proto
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////
// Requests / Responses from /proto/clarifai/api/user.proto
////////////////////////////////////////////////////////////////////////////////
message GetUserRequest {
  // we used to have user_id but moved to the standard convention. Since this endpoint
  // hasn't been exposed and only used by portal as a url tihs won't effect anything external.
  clarifai.api.UserAppIDSet user_app_id = 1;
}

// List all the publicly visible users in the platform.
// On the first page the caller user will always be returned in the first result for the page.
message ListUsersRequest {
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 1;

  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 2;

  // Provide a search query to filter users by id, first name and last name.
  // This supports wildcard queries.
  //   For example, the value "*foo*" will match any user whose id, first name or last name contains "foo".
  // The search is case-insensitive.
  string query = 3;
}

message PostUserConsentRequest {
  // This can be the special user_id "me" as well.
  clarifai.api.UserAppIDSet user_app_id = 1;
  bool consent = 2;
  repeated string fields = 3;
}

message SingleUserResponse {
  clarifai.api.status.Status status = 1;
  User user = 2;
}

message MultiUserResponse {
  clarifai.api.status.Status status = 1;
  repeated User users = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

// This is how you to patch the user object.
// If info.user_id is set then no other field can be set because it's an expensive and dangerous operation.
// All other top level and nested fields can be set separately together.
message PatchUserRequest {
  reserved 1, 6;

  // Provide user id to update.
  // An organization user can update only their own information.
  // An organization admin can update the information of any user in the organization.
  clarifai.api.UserAppIDSet user_app_id = 7;

  // Request to update user information.
  UserInfo info = 2;

  // Request to update password
  UserPassword pass = 3;

  // To handle arbitrary json metadata you can use a struct field:
  // https://github.com/google/protobuf/blob/master/src/google/protobuf/struct.proto
  google.protobuf.Struct metadata = 4;

  clarifai.api.PatchAction action = 5;
}

message PostEmailsRequest {
  // User ID
  clarifai.api.UserAppIDSet user_app_id = 1;
  // Emails to add
  repeated string emails = 2;
}

message SingleEmailResponse {
  // Standard clarifai status code
  clarifai.api.status.Status status = 1;
  // Returns the targeted email.
  EmailAddress email = 2;
}

message MultipleEmailResponse {
  // Standard clarifai status code
  clarifai.api.status.Status status = 1;
  // Returns the targeted emails.
  repeated EmailAddress emails = 2;
}

message ListEmailsRequest {
  // User ID
  clarifai.api.UserAppIDSet user_app_id = 1;
}

message PostResendVerifyRequest {
  // User ID
  clarifai.api.UserAppIDSet user_app_id = 1;
  // Email to verify
  string email = 2;
}

message SingleResendVerifyResponse {
  // Standard clarifai status code
  clarifai.api.status.Status status = 1;
}

message DeleteEmailRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // email address to delete
  string email = 2;
}

message PostPrimaryEmailRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // email address to set as primary
  string email = 2;
}

message PostValidatePasswordRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // password to be validated
  Password password = 2;
}

message SinglePasswordValidationResponse {
  // Standard clarifai status code
  clarifai.api.status.Status status = 1;
  PasswordViolations password_violations = 2;
}

////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////
// Requests / Responses from /proto/clarifai/api/password_policy.proto
////////////////////////////////////////////////////////////////////////////////
message ListGlobalPasswordPoliciesRequest {}

message ListPasswordPoliciesRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // (optional URL parameter) The list of target user id.
  // Defaults to empty list
  repeated string user_ids = 2;
  // (optional URL parameter) The list of target organization id.
  // Defaults to empty list
  repeated string organization_ids = 3;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 4;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 5;
}

message PostPasswordPoliciesRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated PasswordPolicy password_policies = 2;
}

message PatchPasswordPoliciesRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated PasswordPolicy password_policies = 2;

  // The action to perform on the patched objects
  // For now only action 'overwrite' is supported
  string action = 3;
}

message DeletePasswordPoliciesRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // Request to delete several things by the list of ids.
  repeated string ids = 2;
}

message MultiplePasswordPoliciesResponse {
  clarifai.api.status.Status status = 1;
  repeated PasswordPolicy password_policies = 2;
}

////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////
// Requests / Responses from /proto/clarifai/api/user_feature_configs.proto
////////////////////////////////////////////////////////////////////////////////
message UserFeatureConfigRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
}

message SingleUserFeatureConfigResponse {
  clarifai.api.status.Status status = 1;
  string config = 2;
}

////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// Requests / Responses for Organizations
////////////////////////////////////////////////////////////////////////////////

message PostOrganizationsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated Organization organizations = 2;
}

message ListOrganizationsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 2;

  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 3;
}

message ListUsersOrganizationsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 2;

  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 20.
  uint32 per_page = 3;
}

message DeleteRequestingUserFromOrganizationRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
}

message PostAcceptOrganizationInvitationRequest {
  string id = 1;
  // The user_id you're calling with.
  clarifai.api.UserAppIDSet user_app_id = 2;
}

message PostDeclineOrganizationInvitationRequest {
  string id = 1;
  // The user_id you're calling with.
  clarifai.api.UserAppIDSet user_app_id = 2;
}

message GetOrganizationRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
}

message PatchOrganizationRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // Array that has exactly one organization for patching
  repeated Organization organizations = 2;
  // The action to perform on the patched objects
  // For now actions 'merge', 'overwrite', and 'remove' are supported
  string action = 3;
}

message DeleteOrganizationRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
}

message SingleOrganizationResponse {
  clarifai.api.status.Status status = 1;
  Organization organization = 2;
}

message MultiOrganizationResponse {
  clarifai.api.status.Status status = 1;
  repeated Organization organizations = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

message MultiUsersOrganizationsResponse {
  clarifai.api.status.Status status = 1;

  message UserOrganization {
    //wrapper because might need to add role id etc in here in the future
    Organization organization = 1;
    Role role = 2;
    string feature_flag_configs = 3;
  }

  repeated UserOrganization organizations = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

message ListOrganizationMembersRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
}

message PostOrganizationInvitationsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated OrganizationInvitation invitations = 2;
}

message PatchOrganizationInvitationsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string action = 2;
  repeated OrganizationInvitation invitations = 3;
}


enum OrganizationInvitationStatus {
  NOT_SET = 0;
  PENDING = 1;
  ACCEPTED = 2;
  CANCELLED = 3;
  DECLINED = 4;
  EXPIRED = 5;
}

message ListOrganizationInvitationsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 2;

  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 3;

  OrganizationInvitationStatus status = 4;
}

message GetOrganizationInvitationRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string id = 2;
}

message GetOrganizationInvitationPublicRequest {
  string id = 1;
}


message SingleOrganizationInvitationResponse {
  clarifai.api.status.Status status = 1;
  OrganizationInvitation invitation = 2;
}

message MultiOrganizationInvitationResponse {
  clarifai.api.status.Status status = 1;
  repeated OrganizationInvitation invitations = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

message PatchOrganizationMembersRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // The action to perform on the patched objects
  // For now, only action 'overwrite' is supported
  string action = 2;
  message PatchOrganizationMember {
    string id = 1;
    string role_id = 2;
  }
  repeated PatchOrganizationMember organization_members = 3;
}

message PostOrganizationMemberRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string member_id = 2;
  string role_id = 3;
}

message DeleteOrganizationMemberRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string member_id = 2;
}

message MultiOrganizationMemberResponse {
  clarifai.api.status.Status status = 1;

  repeated OrganizationMember organization_members = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// Requests / Responses for IdentityProviders
////////////////////////////////////////////////////////////////////////////////

message PostIdentityProvidersRequest {
  repeated IdentityProvider identity_providers = 1;

  clarifai.api.UserAppIDSet user_app_id = 2;
}

message ListIdentityProvidersRequest {
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 1;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 20.
  uint32 per_page = 2;
  clarifai.api.UserAppIDSet user_app_id = 3;
}

message GetIdentityProviderRequest {
  string id = 1;
  clarifai.api.UserAppIDSet user_app_id = 2;
}

message PatchIdentityProvidersRequest {
  repeated IdentityProvider identity_providers = 1;
  // The action to perform on the patched objects
  // For now actions 'merge', 'overwrite', and 'remove' are supported
  string action = 3;
  clarifai.api.UserAppIDSet user_app_id = 4;
}

message DeleteIdentityProvidersRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated string ids = 2;
}

message SingleIdentityProviderResponse {
  clarifai.api.status.Status status = 1;
  IdentityProvider identity_provider = 2;
}

message MultiIdentityProviderResponse {
  clarifai.api.status.Status status = 1;
  repeated IdentityProvider identity_providers = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// Requests / Responses for Teams
////////////////////////////////////////////////////////////////////////////////

message PostTeamsRequest {

  message PostTeam {
    // Identify the team (unique).
    string id = 1;

    // When the team was created.
    // The format is https://www.ietf.org/rfc/rfc3339.txt.
    // Example: "2006-01-02T15:04:05.999999Z".
    google.protobuf.Timestamp created_at = 2;

    // Most recent time when the team was updated.
    // The format is https://www.ietf.org/rfc/rfc3339.txt.
    // Example: "2006-01-02T15:04:05.999999Z".
    google.protobuf.Timestamp modified_at = 3;

  // Name the team.
    string name = 4;
  }

  repeated PostTeam teams = 1;
  clarifai.api.UserAppIDSet user_app_id = 2;
}

message ListTeamsRequest {
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1
  uint32 page = 1;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 20.
  uint32 per_page = 2;

  // Provide a search query to filter teams by name and id.
  // This supports wildcard queries.
  //   For example, the value "*foo*" will match any team whose name or id contains "foo".
  // The search is case-insensitive.
  string query = 3;
  clarifai.api.UserAppIDSet user_app_id = 4;

}

message GetTeamRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string id = 2;
}

message PatchTeamsRequest {
  repeated Team teams = 1;
  // The action to perform on the patched objects
  // For now actions 'merge', 'overwrite', and 'remove' are supported
  string action = 2;
  clarifai.api.UserAppIDSet user_app_id = 3;
}

message DeleteTeamsRequest {
  repeated string ids = 1;
  clarifai.api.UserAppIDSet user_app_id = 2;
}

message SingleTeamResponse {
  clarifai.api.status.Status status = 1;
  Team team = 2;
}

message MultiTeamResponse {
  clarifai.api.status.Status status = 1;
  repeated Team teams = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

message AppIdentity {
  string user_id = 1;
  string app_id = 2;
}

message ListTeamAppsRequest {
  string team_id = 1;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 2;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 3;

  // Provide a search query to filter apps by id and name.
  // This supports wildcard queries.
  // For example, the value "*foo*" will match any app whose id or name contains "foo".
  // The search is case-insensitive.
  string query = 4;
  clarifai.api.UserAppIDSet user_app_id = 5;

}

message PostTeamAppsRequest {
  message TeamApp {
    //removing the AppIdentity, this was only needed when you could add any app to a team, rn only apps from the same org can be added so we implicitly already
    //know which user the app belongs that is added. It's a breaking change but it's OK since this was never public.
    //AppIdentity app = 1;
    string app_id = 1;
    string role_id = 2;
  }

  string team_id = 1;
  repeated TeamApp apps = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
  clarifai.api.UserAppIDSet user_app_id = 3;
}

message DeleteTeamAppsRequest {
  string team_id = 1;
  repeated string app_ids = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
  clarifai.api.UserAppIDSet user_app_id = 3;
}

message MultiTeamAppsResponse {
  message TeamApp {
    string team_id = 1;
    string role_id = 2;

    //todo(margus) should we get rid of this AppIdentity message? it made sense when teams was global but now that is is org scoped it kind of could be removed
    AppIdentity app = 3;

    string app_name = 4;
    string role_name = 5;
  }

  clarifai.api.status.Status status = 1;
  repeated TeamApp apps = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
  clarifai.api.UserAppIDSet user_app_id = 3;
}

message PostTeamUsersRequest {
  string team_id = 1;
  repeated string user_ids = 2;
  clarifai.api.UserAppIDSet user_app_id = 3;
}

message ListTeamUsersRequest {
  string team_id = 1;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 2;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 20.
  uint32 per_page = 3;
  // Provide a search query to filter team users by id, first name and last name.
  // This supports wildcard queries.
  //   For example, the value "*foo*" will match any team user whose id, first name or last name contains "foo".
  // The search is case-insensitive.
  string query = 4;
  clarifai.api.UserAppIDSet user_app_id = 5;
}

message DeleteTeamUsersRequest {
  string team_id = 1;
  repeated string user_ids = 2;
  clarifai.api.UserAppIDSet user_app_id = 3;
}

message MultiTeamUserResponse {
  clarifai.api.status.Status status = 1;
  repeated TeamUser team_users = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}


////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// Requests / Responses for Roles
////////////////////////////////////////////////////////////////////////////////

message ListRolesRequest {
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 1;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 20.
  uint32 per_page = 2;
  // Optional query parameter that will add filter by type. Possible values 'ORG' or 'TEAM'.
  repeated RoleType types = 3;
}

message GetRoleRequest {
  string id = 1;
}

message SingleRoleResponse {
  clarifai.api.status.Status status = 1;
  Role role = 2;
}

message MultiRoleResponse {
  clarifai.api.status.Status status = 1;
  repeated Role roles = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

////////////////////////////////////////////////////////////////////////////////

////////////////////////////////////////////////////////////////////////////////
// Requests / Responses from /proto/clarifai/api/video.proto
////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////




////////////////////////////////////////////////////////////////////////////////
// Requests / Responses from /proto/clarifai/api/vocab.proto
////////////////////////////////////////////////////////////////////////////////
//////////////////////
// Responses
//////////////////////
// Requests
//////////////////////
// GET single vocab by id.
message GetVocabRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string vocab_id = 2;
}

// List multiple vocabs.
message ListVocabsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 2;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 3;
}

// POST new vocabs with this.
message PostVocabsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated Vocab vocabs = 2;
}

// PATCH one or more vocabs with this endpoint.
message PatchVocabsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // The list of updates fields for the vocabs. Must have the "id" field set so that it can match on
  // of the existing vocabs.
  repeated Vocab vocabs = 2;

  // The action to perform on the patched objects
  // For now only action 'overwrite' is supported
  string action = 3;
}

message DeleteVocabRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string vocab_id = 2;
}

// Request to delete several things by the list of ids.
message DeleteVocabsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated string ids = 2;
  bool delete_all = 3;
}

// List concepts in a vocab. There is
message ListVocabConceptsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string vocab_id = 2;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 3;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 4;
}

// Add a concept(s) to the END of the vocab list.
message PostVocabConceptsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string vocab_id = 2;
  repeated Concept concepts = 3;
}

// This lets you delete a specific concept from the vocab (not from your app).
message DeleteVocabConceptRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string vocab_id = 2;
  string concept_id = 3;
}

// Request to delete several concepts from vocab by the list of ids.
// The delete_all in this case will empty the vocab to start over.
// In either case the concepts will remain in your app.
message DeleteVocabConceptsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string vocab_id = 2;
  repeated string ids = 3;
  bool delete_all = 4;
}

//////////////////////
// Responses
//////////////////////
// A single vocab to return.
message SingleVocabResponse {
  clarifai.api.status.Status status = 1;
  Vocab vocab = 2;
}

// Multiple vocabs to return.
message MultiVocabResponse {
  clarifai.api.status.Status status = 1;
  repeated Vocab vocabs = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

////////////////////////////////////////////////////////////////////////////////



////////////////////////////////////////////////////////////////////////////////
// Requests / Responses from /proto/clarifai/api/workflow.proto
////////////////////////////////////////////////////////////////////////////////
message GetWorkflowRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  // Workflow ID to retrieve
  // If no ID is specified we return default workflow of the application
  // If an ID is specified by default we first looks into Clarifai workflows for a Workflow ID
  string workflow_id = 2;

  // Use this flag to look into clarifai published workflows first for a Workflow ID
  bool favor_clarifai_workflows = 3;
}

message ListWorkflowsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 2;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 3;
}

message ListPublicWorkflowsRequest {
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 1;
  // (optional URL parameter) The number of results that will be contained in each page.
  // Defaults to 128.
  uint32 per_page = 2;
  // Return only base workflows.
  bool only_base = 3;
  // The caller user_id
  clarifai.api.UserAppIDSet user_app_id = 4;
}

message PostWorkflowsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated Workflow workflows = 2;
}

message PatchWorkflowsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated Workflow workflows = 2;

  // The action to perform on the patched objects
  // For now actions 'merge', 'overwrite', and 'remove' are supported
  string action = 3;
}

message DeleteWorkflowRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string workflow_id = 2;
}

// Request to delete several things by the list of ids.
message DeleteWorkflowsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated string ids = 2;
  bool delete_all = 3;
}

message SingleWorkflowResponse {
  clarifai.api.status.Status status = 1;
  Workflow workflow = 2;
}


message MultiWorkflowResponse {
  clarifai.api.status.Status status = 1;
  repeated Workflow workflows = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

message PostWorkflowResultsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  // Workflow ID to retrieve
  // If no ID is specified we return default workflow of the application
  // If an ID is specified by default we first looks into Clarifai workflows for a Workflow ID
  string workflow_id = 2;

  repeated Input inputs = 3;
  // FIXME(zeiler): the request for post workflows is using an outputconfig object that is supposed
  // to be within models. This is not consistent with setting this on the request for post model
  // outputs where it is inside a model object. To make this consistent we would send in the
  // workflow object so that each model can have it's own output config. If nobody is setting
  // this OutputConfig it would probably be easier to just remove it for now to keep things simpler
  // and then it's more consistent we just don't support the OutputConfig on workflows.
  OutputConfig output_config = 4;

  // Use this flag to look into clarifai published workflows first for a Workflow ID
  bool favor_clarifai_workflows = 5;
}

message PostWorkflowResultsResponse {
  clarifai.api.status.Status status = 1;
  Workflow workflow = 2;
  repeated WorkflowResult results = 3;
}

message PostWorkflowResultsSimilarityRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string workflow_id = 2;
  // The specific model version whose outputs we are comparing
  string model_version_id = 3;
  // Each probe is compared against every pool input
  repeated Input probe_inputs = 4;
  // Each pool input is compared against ever probe input
  repeated Input pool_inputs = 5;
  // Use this flag to look into clarifai published workflows first for a Workflow ID
  bool favor_clarifai_workflows = 6;
}

message PostWorkflowResultsSimilarityResponse {
  clarifai.api.status.Status status = 1;
  repeated WorkflowResultsSimilarity results = 2;
}

////////////////////////////////////////////////////////////////////////////////
// Workflow Operators

message GetOperatorTypeRequest {
  // Identify the operator type you want to retrieve.
  string operator_type_id = 1;
}

message ListOperatorTypesRequest {
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 1;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 2;
}

message SingleOperatorTypeResponse {
  // Status of the response.
  clarifai.api.status.Status status = 1;
  // The retrieved ModelType object. .
  OperatorType operator_type = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

message MultiOperatorTypeResponse {
  // Status of the response.
  clarifai.api.status.Status status = 1;
  // List of OperatorType objects.
  repeated OperatorType operator_types = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

////////////////////////////////////////////////////////////////////////////////
// Workflow Metrics
////////////////////////////////////////////////////////////////////////////////

message PostWorkflowMetricsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  // Identify the workflow.
  string workflow_id = 2;

  // Specify list of workflow metrics data to add.
  // All fields are optional.
  // Allowed fields to set:
  // * id
  // - provide custom id for the evaluation
  // - if empty, then an id is automatically generated
  // * data
  // - provide concepts to be used for this evaluation
  // - if empty, then all app concepts are used
  // - Example: "data": {
  //                "concepts": [{"id": "{{concept_id}}"}]
  //            }
  // * node_metrics
  // - provide the workflow nodes to be evaluated
  // - if empty, then all evaluable workflow nodes will be evaluated
  // - Example: "node_metrics": {
  //               "node_1": {},
  //               "node_2": {},
  //            }
  // * ground_truth
  // - provide the ground truth data set to search for
  // - if not set, then ground truth is retrieved from current app's inputs and annotations
  // - Example: "ground_truth": {
  //                "query": {
  //                    "ands": {
  //                        "annotation": {
  //                            "data": {
  //                                "concepts": [{"id": "concept"}]
  //                            }
  //                        }
  //                     }
  //                },
  //            }
  repeated WorkflowMetrics workflow_metrics = 3;
}

message GetWorkflowMetricsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  // Identify the workflow.
  string workflow_id = 2;

  // Identify the workflow metrics.
  string metrics_id = 3;
}

message GetWorkflowNodeMetricsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  // Identify the workflow.
  string workflow_id = 2;

  // Identify the workflow metrics.
  string metrics_id = 3;

  // Identify the workflow node.
  string node_id = 4;
}

message ListWorkflowMetricsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // Identify the workflow.
  string workflow_id = 2;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 3;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 4;
}

message DeleteWorkflowMetricsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  // Identify the workflow.
  string workflow_id = 2;

  // Identify the list workflow metrics to delete.
  repeated string ids = 3;
}

message SingleWorkflowMetricsResponse {
  clarifai.api.status.Status status = 1;

  // Workflow metrics data.
  WorkflowMetrics workflow_metrics = 2;
}

message SingleWorkflowNodeMetricsResponse {
  clarifai.api.status.Status status = 1;

  // Workflow node metrics data.
  EvalMetrics node_metrics = 2;
}

message MultiWorkflowMetricsResponse {
  clarifai.api.status.Status status = 1;

  // List of workflow metrics.
  repeated WorkflowMetrics workflow_metrics = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

////////////////////////////////////////////////////////////////////////////////
// App Duplication
////////////////////////////////////////////////////////////////////////////////

//Request to start a app duplication process
message PostAppDuplicationsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated AppDuplication app_duplications = 2;
}

//Request to check app duplication status
message GetAppDuplicationRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  //The app duplication id
  string app_duplication_id = 2;
}

//Request to list all the app duplication that user triggered.
message ListAppDuplicationsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 2;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 3;
}

message MultiAppDuplicationsResponse {
  clarifai.api.status.Status status = 1;
  repeated AppDuplication app_duplications = 2;
}


message SingleAppDuplicationResponse {
  clarifai.api.status.Status status = 1;
  AppDuplication app_duplication = 2;
}

////////////////////////////////////////////////////////////////////////////////
// Tasks
////////////////////////////////////////////////////////////////////////////////

// Request to create Tasks.
message PostTasksRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated Task tasks = 2;
}

// Request to get one task.
message GetTaskRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string task_id = 2;
}

// Request to list multiple tasks.
message ListTasksRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 2;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 3;
  // Get tasks that have ANY user from this list assigned as worker.
  repeated string worker_user_ids = 4;
  // Get tasks that have ANY user from this list assigned as reviewer.
  repeated string review_user_ids = 5;
  // Get label order tasks as well
  bool including_label_order_tasks = 6;
}

// Request to patch a list of tasks.
message PatchTasksRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated Task tasks = 2;
  // The action to perform on the patched objects
  // For now actions 'merge', 'overwrite', and 'remove' are supported
  string action = 3;
}

// Request to delete a list of tasks.
message DeleteTasksRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated string ids = 2;
}

// Response with multiple Tasks.
message MultiTaskResponse {
  clarifai.api.status.Status status = 1;
  repeated Task tasks = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

// Response with a single Task.
message SingleTaskResponse {
  clarifai.api.status.Status status = 1;
  Task task = 2;
}

// GetTaskCountRequest can be used for fetching -
// 1. Task annotation count per user, per status
// 1. Task input (anchor annotations) count per user, per status
message GetTaskCountRequest{
  clarifai.api.UserAppIDSet user_app_id = 1;

  // task_id for which count per user per status is needed
  string task_id = 2;

  // for given task_id, user_ids to filter on (optional)
  repeated string user_ids= 3;
}


// SingleTaskCountResponse represent counts of annotations or inputs(anchor annotations) for labelers in given task
message SingleTaskCountResponse {
  clarifai.api.status.Status status = 1;
  string app_id = 2;
  string task_id = 3;
  repeated TaskStatusCountPerUser counts = 4;
}

////////////////////////////////////////////////////////////////////////////////
// Label Orders
////////////////////////////////////////////////////////////////////////////////

// Request to create label orders.
message PostLabelOrdersRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated LabelOrder label_orders = 2;
}

// Request to get one label order.
message GetLabelOrderRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  string label_order_id = 2;
}

// Request to list multiple label orders.
message ListLabelOrdersRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 2;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 3;
}

// Request to patch a list of label orders.
message PatchLabelOrdersRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  repeated LabelOrder label_orders = 2;

  // The action to perform on the patched objects
  // For now actions 'merge', 'overwrite', and 'remove' are supported
  string action = 3;
}

// Request to delete a list of tasks.
message DeleteLabelOrdersRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated string ids = 2;
}

// Response with multiple label order.
message MultiLabelOrderResponse {
  clarifai.api.status.Status status = 1;
  repeated LabelOrder label_orders = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}

// Response with a label order.
message SingleLabelOrderResponse {
  clarifai.api.status.Status status = 1;
  LabelOrder label_order = 2;
}

////////////////////////////////////////////////////////////////////////////////
// Collectors
////////////////////////////////////////////////////////////////////////////////

// Request to create Collectors.
message PostCollectorsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated Collector collectors = 2;
}

message PatchCollectorsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;

  repeated Collector collectors = 2;

  // The action to perform on the patched objects
  // For now actions 'merge', 'overwrite', and 'remove' are supported
  string action = 3;
}

// Request to delete several things by the list of ids.
message DeleteCollectorsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated string ids = 2;
  bool delete_all = 3;
}

// Request to GET a single Collector.
message GetCollectorRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  //The collecgtor id
  string collector_id = 2;
}

// Request to GET all the Collectors.
message ListCollectorsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 2;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 3;
}

// Response with multiple Collectors.
message MultiCollectorResponse {
  clarifai.api.status.Status status = 1;
  repeated Collector collectors = 2;
}

// Response with a single Collector.
message SingleCollectorResponse {
  clarifai.api.status.Status status = 1;
  Collector collector = 2;
}



////////////////////////////////////////////////////////////////////////////////
// Stats Collection Endpoints.
////////////////////////////////////////////////////////////////////////////////
message PostStatValuesRequest {
  // The user and app information for the request.
  clarifai.api.UserAppIDSet user_app_id = 1;
  // The stats to post, can post more than one at a time.
  repeated StatValue stat_values = 2;
}

message MultiStatValueResponse {
  // The response status.
  clarifai.api.status.Status status = 1;
  // The returned stats values.
  repeated StatValue stat_values = 2 [(clarifai.api.utils.cl_show_if_empty) = true];
}


message PostStatValuesAggregateRequest {
  // Ids present in the url of the request.
  clarifai.api.UserAppIDSet user_app_id = 1;

  // Query to retrieve aggregate values.
  repeated StatValueAggregateQuery stat_value_aggregate_queries = 2;
}

message MultiStatValueAggregateResponse {
  // The response status.
  clarifai.api.status.Status status = 1;

  // The aggregate results for each query passedin.
  repeated StatValueAggregateResult stat_value_aggregate_results = 2;
}

////////////////////////////////////////////////////////////////////////////////
// SDK Endpoints. Will be deprecated
////////////////////////////////////////////////////////////////////////////////

message PostAnalyticsRequest {
  // Unique identifier for this data packet, in order to avoid duplicates on the server side
  string batch_unique_identifier = 1;
  DeviceInfo device_info = 2;
  repeated SDKEventsCollection events_collection = 3;
  HostAppInfo host_app_info = 4;
  OperatingSystem operating_system = 5;
  State state = 6;
  string system_uuid = 7;                   // System unique identifier for the combination user + device
  google.protobuf.Timestamp timestamp = 8;  // Timestamp the data was persisted on the device
  SDK sdk = 9;
}

message PostAnalyticsResponse {
  clarifai.api.status.Status status = 1;
}

message PostSDKBillingRequest {
  string batch_unique_identifier = 1; // Unique identifier for this data packet, in order to avoid duplicates on the server side
  DeviceInfo device_info = 2;
  SDKBillingCycle cycle = 3;
  HostAppInfo host_app_info = 4;
  OperatingSystem operating_system = 5;
  State state = 6;
  string system_uuid = 7; // System unique identifier for the combination user + device
  SDK sdk = 8;
}

message PostSDKBillingResponse {
  clarifai.api.status.Status status = 1;
  clarifai.commands.Commands commands = 2;
}

message MultiFindDuplicateAnnotationsJobResponse {
  clarifai.api.status.Status status = 1;
  // The find duplicate annotation jobs that were started
  repeated FindDuplicateAnnotationsJob find_duplicate_annotations_jobs = 2;
}

message PostFindDuplicateAnnotationsJobsRequest {
  // The user_id and app_id information.
  clarifai.api.UserAppIDSet user_app_id = 1;
  // The find duplicate annotation jobs that are being started
  repeated FindDuplicateAnnotationsJob find_duplicate_annotations_jobs = 2;
}

message GetFindDuplicateAnnotationsJobsRequest{
  clarifai.api.UserAppIDSet user_app_id = 1;
  string id = 2;
}

message ListFindDuplicateAnnotationsJobsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  // (optional URL parameter) The page number. Pagination is used to split the results into chunks.
  // Defaults to 1.
  uint32 page = 2;
  // (optional URL parameter) The number of results that will be contained in each page. Defaults
  // to 128.
  uint32 per_page = 3;
}

message DeleteFindDuplicateAnnotationsJobsRequest {
  clarifai.api.UserAppIDSet user_app_id = 1;
  repeated string ids = 2;
}
